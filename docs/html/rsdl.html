<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>RESTful Service Description Language (RSDL)</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><meta name="description" content="RESTful Service Description Language (RSDL) is an XML vocabulary for designing and documenting hypermedia-driven RESTful Services. RSDL takes a purist hypermedia-driven approach to REST design, requiring that a service have a single entry point, and focusing the design on resources, links, and media types."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><div><div><h2 class="title"><a name="HR-23632987-8973"></a>RESTful Service Description Language (RSDL)</h2></div><div><h3 class="subtitle"><i>Describing RESTful Services Without Tight Coupling</i></h3></div><div><div class="author"><h3 class="author"><span class="firstname">Jonathan</span> <span class="surname">Robie</span></h3><div class="affiliation"><span class="orgname">EMC Corporation<br></span></div><code class="email">&lt;<a class="email" href="mailto:jonathan.robie@emc.com">jonathan.robie@emc.com</a>&gt;</code></div></div><div><div class="author"><h3 class="author"><span class="firstname">Rob</span> <span class="surname">Cavicchio</span></h3><div class="affiliation"><span class="orgname">EMC Corporation<br></span></div><code class="email">&lt;<a class="email" href="mailto:rob.cavicchio@emc.com">rob.cavicchio@emc.com</a>&gt;</code></div></div><div><div class="author"><h3 class="author"><span class="firstname">R&eacute;mon</span> <span class="surname">Sinnema</span></h3><div class="affiliation"><span class="orgname">EMC Corporation<br></span></div><code class="email">&lt;<a class="email" href="mailto:remon.sinnema@emc.com">remon.sinnema@emc.com</a>&gt;</code></div></div><div><div class="author"><h3 class="author"><span class="firstname">Erik</span> <span class="surname">Wilde</span></h3><div class="affiliation"><span class="orgname">EMC Corporation<br></span></div><code class="email">&lt;<a class="email" href="mailto:erik.wilde@emc.com">erik.wilde@emc.com</a>&gt;</code></div></div><div><p class="copyright">Copyright &copy; 2013 EMC Corporation.  
      Except where otherwise noted, this content is licensed under a Creative Commons Attribution 3.0 License.  Schemas and stylesheets in this document are licensed under an Apache 2.0 License.</p></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>RESTful Service Description Language (RSDL) is an XML vocabulary for designing and
        documenting hypermedia-driven RESTful Services. RSDL takes a purist hypermedia-driven
        approach to REST design, requiring that a service have a single entry point, and focusing
        the design on resources, links, and media types.</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d5e46">Introduction</a></span></dt><dt><span class="section"><a href="#d5e53">What should a RESTful service description describe?</a></span></dt><dt><span class="section"><a href="#d5e90">A Sample RSDL Description</a></span></dt><dt><span class="section"><a href="#d5e99">The Structure of a RSDL Description</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e102">Service</a></span></dt><dt><span class="section"><a href="#d5e120">Media Types</a></span></dt><dt><span class="section"><a href="#d5e152">Resources</a></span></dt><dt><span class="section"><a href="#d5e215">Link Relations</a></span></dt><dt><span class="section"><a href="#d5e220">Headers</a></span></dt><dt><span class="section"><a href="#d5e224">Authentication</a></span></dt><dt><span class="section"><a href="#d5e230">Status Codes</a></span></dt><dt><span class="section"><a href="#d5e236">URI Parameters</a></span></dt><dt><span class="section"><a href="#d5e242">Documentation Modules</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e262">Initial Experience</a></span></dt><dt><span class="section"><a href="#d5e270">Future Work</a></span></dt><dt><span class="section"><a href="#d5e277">Conclusions</a></span></dt><dt><span class="appendix"><a href="#appx-rsdl.rnc">A. RSDL Schema</a></span></dt><dt><span class="appendix"><a href="#appx-html-subset">B. HTML module for RSDL Documentation</a></span></dt><dt><span class="appendix"><a href="#appx-docbook-subset">C. DocBook module for RSDL Documentation</a></span></dt><dt><span class="appendix"><a href="#appx-xslt-stylesheet">D. An XSLT Stylesheet for RSDL</a></span></dt><dt><span class="appendix"><a href="#appx-planets.rsdl">E. RSDL Description for the Planets Service</a></span></dt><dt><span class="bibliography"><a href="#d5e301">Bibliography</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e46"></a>Introduction</h2></div></div></div><p>RESTful Service Description Language (RSDL) is an XML vocabulary for designing and
      documenting hypermedia-driven RESTful Services. RSDL takes a purist hypermedia-driven approach
      to REST design, requiring that a service have a single entry point, and focusing the design on
      resources, links, and media types. By representing the concepts of REST in a formal
      vocabulary, RSDL helps designers of an interface think more clearly about the design process.
      In our work at EMC Corporation, we teach and coach RESTful design, evaluate proposed REST
      interfaces for products and internal services, and produce documentation for these interfaces.
      We created RSDL to make our work more efficient, and we have begun using it as a teaching
      tool, a standard format for specifications that allows us to track design changes in source
      code control, test for design consistency with specification-driven programs, and produce
      documentation.</p><p>The REST community has little consensus on how to document a RESTful service beyond this
      well-known Roy Fielding quote: </p><div class="blockquote"><blockquote class="blockquote"><p>Any effort spent describing what methods to use on what URIs of interest should be
          entirely defined within the scope of the processing rules for a media type (and, in most
          cases, already defined by existing media types). [Failure here implies that out-of-band
          information is driving interaction instead of hypertext.]</p></blockquote></div><p>While this gives excellent guidance about things that should not be documented,
      it tells us that we should focus on documenting a media type without telling us how to do so.
      Well-designed RESTful services are loosely coupled, allowing a client to use the service with
      no prior knowledge beyond an initial URI and a set of media types. But this gives little
      concrete guidance to a person who is specifying a RESTful service, and needs to know precisely
      what information should be provided to a client, which fundamential concepts should be
      documented for a media type, how dependencies on multiple media types in a single service
      should be represented, where to document semantics specific to the application domain, or how
      to organize all of the information that belongs in a specification. </p><p>This paper presents RESTful Service Description Language (RSDL, pronounced "risdle"), an
      XML vocabulary that provides a structured way to specify a RESTful service. RSDL is still
      being developed.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e53"></a>What should a RESTful service description describe?</h2></div></div></div><p>The description for a RESTful service should describe semantics specific to the service
      that go beyond functionality known to a generic REST client. In RSDL, every RESTful service
      has a single entry point, which corresponds to a home resource, and all other resources can be
      discovered from the home resource using links. The structure of a RSDL description enforces
      these design constraints. </p><p>A RSDL description focuses on describing the following items:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Media types, with documentation and an optional link to a schema or description that
          documents each media type used in a service. This includes the kinds of response bodies
          sent by the server, and how to find links in them and identify specific kinds of
          link.</p></li><li class="listitem"><p>Resources, designating one resource as the service entry point.</p></li><li class="listitem"><p>Links for each resource and the resources they refer to.</p></li><li class="listitem"><p>Methods allowed for each resource, and the associated requests and responses.</p></li><li class="listitem"><p>HTTP headers, including custom headers.</p></li><li class="listitem"><p>Authentication mechanisms and identity providers, which can be specified for the
          entire service or at the individual resource level.</p></li><li class="listitem"><p>URI parameters and URI templates.</p></li><li class="listitem"><p>HTTP status codes, which are described at the service level (not at the individual
          request level or the resource level), but can be referenced at the request level if need
          be.</p></li></ul></div><p>It is important to clearly understand the relationship between services, resources, links,
      URIs, methods, representations, and media types. A RESTful service is a collection of
      resources, which are identified by URIs. To start using a service, a client needs an entry
      point. A service's published entry point is the URI of the home resource. All other resources
      should be discoverable from the home resource using links, which identify URIs that refer to
      other resources, and can be used for HTTP requests. A client can do a <code class="code">GET</code> to
      obtain a representation of a resource in, say, XML or JSON. A representation is a sequence of
      bytes that represents the current state of a resource; the syntax and semantics of a
      representation are defined by the corresponding media type. Note that a representation is not
      the same thing as a resource, it is merely the data required to represent the resource's
      state. You cannot send HTTP requests to a representation, you send HTTP requests to a
      resource. You cannot parse or generate a resource, you can parse or generate a representation.
      These distinctions are important, and they are reflected in the structure of RSDL. For
      instance, a media type can provide schemas or descriptions that describe the structure of its
      representations. A resource describes the HTTP requests that can be applied to a resource. In
      RSDL, we view links as an abstraction that represents the potential relationship among
      resources, they have a concrete representation in a given media type. If a given resource has
      both an XML representation and a JSON representation, the same links will be represented in
      different ways by the two media types.</p><p>In addition to information that is provided for the benefit of REST clients, some other
      aspects of a REST design should be specified in a structured way simply for the purpose of
      fostering consistent design in the implementation. The design and structure of URIs is a
      particularly important example of this&#8212;clients should treat URIs as opaque, but server-side
      implementations need to understand the URIs they respond to, and URIs often contain metadata
      that is useful for someone who is learning an API interactively, so consistent structure in
      URIs is important. The purist side of us would like to leave the structure of URIs completely
      out of the specification, but in practice, the URI formats often link the specification to the
      actual implementation. RSDL allow the structure of a URI to be specified, and variable
      portions of a URI can be specified using a URI template (<a class="xref" href="#rfc6570">URI Templates</a>). Our
      documentation stylesheets omit the URI structure in client API documentation for all resources
      except the home resource.</p><p>This information is highly structured, with many cross references and semantic
      constraints, but it is typically documented in formats like HTML, Wiki pages, or word
      processing documents, which offer no aid in getting the structure right. And although this
      information is often reused in many different ways, it is not generally created in formats
      that foster reuse. Beyond that, an XML representation of a RESTful web service is extremely
      useful for teaching RESTful service design, creating and maintain designs over time alongside
      implementation code, guiding the process of design, visualizing and evaluating service designs
      created by others, generating various forms of human and machine-readable documentation,
      providing data for testing clients, and generating stubs for server-side code. The structure
      of RSDL's schema can guide the design process, nudging designs to be more RESTful<a href="#ftn.d5e79" class="footnote" name="d5e79"><sup class="footnote">[1]</sup></a>.</p><p>A RESTful service typically needs to document additional information beyond normal HTTP
      semantics. RSDL allows the following to be documented either in schemas or documentation
      associated with a mediatype, or in documentation elements, which allow documentation to be
      written in HTML, DocBook, or other formats, and can be placed throughout a RSDL description.
      This information includes:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Application semantics that are orthogonal to REST per se. This is information that is
          completely unknown to a generic REST client, but this information largely defines what the
          application is all about. This includes the application semantics of most XML elements or
          JSON properties. For instance, in Atom, these semantics include the meaning of container
          elements like feeds, entries, and content, and metadata elements like author, category,
          and contributor, etc. In the HTML media type, these semantics include all intended browser
          behavior implied by the data that does not involve the use of links.</p></li><li class="listitem"><p>Protocol semantics added by a particular media type. For instance, the Atom Publishing
          Protocol specifies that a POST to a collection URI adds a new member to a collection, a
          side-effect that would be difficult for a generic client to discover if it had no
          knowledge of the media type.</p></li></ul></div><p> The best-known description language for REST is <a class="xref" href="#WADL">WADL</a>. WADL provides a
      detailed, well-structured description of a REST interface, but the structure of WADL is driven
      by URI patterns and server-side implementation concerns rather than hypermedia-driven design.
      WADL has been criticized for inviting URI-based tight coupling between the client and the
      server, so that changes to server-side code can break existing clients. From a REST
      perspective, the main problem with WADL is that it exposes interfaces using static metadata,
      instead of describing conventions for discovering and using links, and even provides tools to
      create stub code for clients and servers from the WADL description, code that is guaranteed to
      rely on this static metadata. WADL directly exposes URIs and fixed paths instead of relying on
      links, documents specific errors instead of relying on generic HTTP processing, and does not
      distinguish information needed to specify the server from information provided to the client
      interface. </p><p>In many ways, RSDL is similar to WADL, with a great deal of overlap in the information
      that is represented. But RSDL is designed for hypermedia-driven services. In RSDL, every
      service has a single published entry point, which corresponds to a home resource, and all
      other resources can be discovered from the home resource using links. Like WADL, RSDL
      describes resources and relationships among resources, but RSDL always uses links to describe
      relationships. Like WADL, RSDL describes the methods that can be used for to a given resource,
      but RSDL does not describe expected error codes for each method; instead, it relies on the use
      of generic HTTP status codes; if specific semantics are required, e.g. to document the use of
      a redirect for authentication purposes, RSDL allows the semantics of a given status code to be
      documented globally for the service. Like WADL, RSDL allows schemas that describe expected
      formats for representations, but RSDL also allows descriptions in other formats, including W3C
      XML Schemas, Relax-NG, JSON Schema, HTML descriptions, text-based descriptions, or anything
      else that can be referred to with a URI. </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e90"></a>A Sample RSDL Description</h2></div></div></div><p>The following RSDL example describes a simple service that supports a collection of
      documents. The service uses several media types: an XML Home document as the entry point, an
      atom feed to represent the collection of documents, an HTML description that describes the
      service, and a media type for the documents used in the service. The schema for RSDL is
      provided <a class="link" href="#appx-rsdl.rnc" title="A.&nbsp;RSDL Schema">in an appendix</a>. Documentation is embedded at
      many points in the description, using a separate documentation module that is included. The
      appendixes provide documentation modules for <a class="link" href="#appx-html-subset" title="B.&nbsp;HTML module for RSDL Documentation">HTML</a> and
        <a class="link" href="#appx-docbook-subset" title="C.&nbsp;DocBook module for RSDL Documentation">DocBook</a>, this example uses the HTML
      module.</p><pre class="programlisting">
      <span class="emphasis"><em>The Documents Service</em></span>

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;service name="Documents" 
  identity-provider-ref="idp" 
  xmlns="http://identifiers.emc.com/rsdl"
  xmlns:html="http://www.w3.org/1999/xhtml/"&gt;

  &lt;documentation&gt;This RESTful service provides a simple ATOM feed that allows documents to be read,
    created, modified, or deleted. &lt;/documentation&gt;

  &lt;start ref="res-home"/&gt;

  &lt;media-types&gt;
    &lt;media-type id="med-document" name="application/vnd.example.document+xml"&gt;
      &lt;documentation&gt; The media type for the service described by this RSDL description.&lt;/documentation&gt;
      &lt;description href="example.com/mediatypes/documents.rnc" type="rnc"/&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-home-xml" name="application/home+xml"&gt;
      &lt;documentation&gt; Home Documents for HTTP Services: XML Syntax &lt;/documentation&gt;
      &lt;description href="http://tools.ietf.org/html/draft-wilde-home-xml-01.html" type="html"/&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-atom" name="application/atom+xml"&gt;
      &lt;documentation&gt; Atom feeds, updateable using AtomPub conventions, with feed paging.
      &lt;/documentation&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-html" name="text/html"&gt;
      &lt;documentation&gt; HTML documents. &lt;/documentation&gt;
    &lt;/media-type&gt;
  &lt;/media-types&gt;

  &lt;resources&gt;
    &lt;resource id="res-home" name="home"&gt;
      &lt;location uri="/"/&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-documents" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-about" resource-ref="res-about"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-home-xml" entity="resources"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;

    &lt;resource id="res-documents" name="documents"&gt;
      &lt;location uri="/documents"/&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-self" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-first" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-next" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-last" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-previous" resource-ref="res-documents"/&gt;

        &lt;link link-relation-ref="rel-alternate" resource-ref="res-document"&gt;
          &lt;documentation&gt; 
            In an ATOM feed, we use the alternate link relation to indicate the member
            type. 
          &lt;/documentation&gt;
        &lt;/link&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-atom" entity="atom:feed"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
        &lt;method name="POST"&gt;
          &lt;request&gt;
            &lt;documentation&gt;Creates a document&lt;/documentation&gt;
            &lt;representation media-type-ref="med-document" entity="document"/&gt;
          &lt;/request&gt;
          &lt;response&gt;
            &lt;documentation&gt;Returns the newly created document&lt;/documentation&gt;
            &lt;representation media-type-ref="med-document" entity="document"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;

    &lt;resource id="res-document" name="document"&gt;
      &lt;documentation&gt; &lt;/documentation&gt;
      &lt;location template="/document/{oid}"&gt;
        &lt;var name="oid"&gt;
          &lt;documentation&gt; Identifier for the document. &lt;/documentation&gt;
        &lt;/var&gt;
      &lt;/location&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-self" resource-ref="res-document"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-document" entity="res-document"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;

        &lt;method name="PUT"&gt;
          &lt;request&gt;
            &lt;representation media-type-ref="med-document" entity="res-document"/&gt;
          &lt;/request&gt;
        &lt;/method&gt;

        &lt;method name="DELETE"/&gt;

      &lt;/methods&gt;
    &lt;/resource&gt;

    &lt;resource id="res-about" name="about" public="true"&gt;
      &lt;documentation&gt;An HTML page describing the service.&lt;/documentation&gt;
      &lt;location uri="/about"/&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-html" entity="html"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;

  &lt;/resources&gt;

  &lt;link-relations&gt;
    &lt;documentation&gt; Link relations used in the media-type. IANA link relations can be found &lt;ref
        uri="http://www.iana.org/assignments/link-relations/link-relations.xml"&gt;here&lt;/ref&gt;. Non-IANA
      link relations will be registered on identifiers.example.com. &lt;/documentation&gt;

    &lt;link-relation id="rel-about" name="about"/&gt;
    &lt;link-relation id="rel-alternate" name="alternate"/&gt;
    &lt;link-relation id="rel-self" name="self"/&gt;
    &lt;link-relation id="rel-edit" name="edit"/&gt;
    &lt;link-relation id="rel-first" name="first"/&gt;
    &lt;link-relation id="rel-last" name="last"/&gt;
    &lt;link-relation id="rel-next" name="next"/&gt;
    &lt;link-relation id="rel-previous" name="previous"/&gt;
    &lt;link-relation id="rel-parent" name="parent"/&gt;

    &lt;link-relation id="rel-documents" name="identifiers.example.com/linkrel/documents"/&gt;

  &lt;/link-relations&gt;

  &lt;headers&gt;
    &lt;header id="hea-authenticate" name="WWW-Authenticate" type="request"/&gt;
  &lt;/headers&gt;

  &lt;authentication&gt;
    &lt;mechanism id="aut-http" name="HTTP Authentication" authentication-type="rfc2617"&gt;
      &lt;documentation&gt; 
        We use HTTP Authentication as defined in &lt;ref uri="http://tools.ietf.org/html/rfc2617"&gt;RFC 2617&lt;/ref&gt; 
        with custom schemes. If an unauthenticated user tries to access a protected resource, a 
        &lt;ref status-code="sta-unauthorized"/&gt; status is returned, along with one or more 
        &lt;ref header="hea-authenticate"/&gt; headers, each of which contains an authentication 
        &lt;html:em&gt;challenge&lt;/html:em&gt;. The challenges consist of a scheme followed by one or more parameters. 
      &lt;/documentation&gt;
      &lt;scheme name="basic"&gt;
        &lt;parameter name="realm"/&gt;
      &lt;/scheme&gt;       
    &lt;/mechanism&gt;
    &lt;identity-provider id="idp" mechanism-ref="aut-http"/&gt;        
  &lt;/authentication&gt;

  &lt;status-codes&gt;
    &lt;status id="sta-unauthorized" code="401"&gt;
      &lt;documentation&gt; The request requires authentication. When this status code is returned, the
        response contains one or more &lt;ref header="hea-authenticate"/&gt; headers that each contain an
          &lt;ref mechanism="aut-http"&gt;authentication challenge&lt;/ref&gt;. &lt;/documentation&gt;
    &lt;/status&gt;
  &lt;/status-codes&gt;
&lt;/service&gt;

    </pre><p>This example will be examined in more detail in the following section.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e99"></a>The Structure of a RSDL Description</h2></div></div></div><p>In this section, we will explore the structure of a RSDL description, using the example
      from the previous section. </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e102"></a>Service</h3></div></div></div><p>The top-level element for a RSDL description is the service element. Here is the
        structure of the service element, in Relax-NG Compact syntax, together with the optional
        attribute used to designate an identity provider for authentication, and a start element
        that identifies the home resource.</p><pre class="programlisting">
start = service
service =
    element service {
        id?,
        name,
        identity-provider-ref?,
        documentation?,
        service-start,
        media-types,
        resources,
        link-relations?,
        headers?,
        authentication?,
        status-codes?,
        uri-parameters?
    }
    
service-start = element start { idref }
idref = attribute ref { xsd:IDREF }

identity-provider-ref = attribute identity-provider-ref { xsd:IDREF }    
        </pre><p>Consider the following fragment:</p><pre class="programlisting">
&lt;service name="Documents"    
  identity-provider-ref="idp"
  xmlns="http://identifiers.emc.com/rsdl"
  xmlns:html="http://www.w3.org/1999/xhtml/"&gt;

  &lt;documentation&gt; This RESTful service provides a simple ATOM feed that allows documents to be read,
    created, modified, or deleted. &lt;/documentation&gt;

  &lt;start ref="res-home"/&gt;

  !!! SNIP !!!
  
 &lt;/service&gt;
        </pre><p>The <code class="code">name</code> of a service is provided primarily for human beings who need to
        refer to the service. REST clients do not use a name to identify a service, they enter a
        service using the URI of the home resource.<a href="#ftn.d5e110" class="footnote" name="d5e110"><sup class="footnote">[2]</sup></a></p><p>The <code class="code">identity-provider-ref</code> attribute refers to an identity provider that can
        be used to authenticate for the service. This attribute is an <code class="code">IDREF</code> that refers
        to an identity provider in the <code class="code">authentication</code> element, which is discussed
        later. If an identity provider is specified, all resources require authentication by
        default, unless declared public (this is described in the section on
        <code class="code">resources</code>). If no identity provider is specified, resources do not require
        authentication by default, but an individual resource can specify an identity
        provider.</p><p>The <code class="code">start</code> element identifies the home resource, which is the published
        entry point for the service. Because every RESTful service should have a single published
        entry point, the <code class="code">start</code> element is required. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e120"></a>Media Types</h3></div></div></div><p>In RSDL, media types describe the resource representations used in a REST service. In
        the systems we design, it is quite common for a service to use multiple media types; for
        instance, the example we are discussing is focused on documents, but it also uses XML Home
        Documents to provide a set of available links in the home resource, uses Atom and AtomPub
        with feeds to represent collections, and uses HTML to provide a human-readable description
        of the service. The resource representations for a media type may be in XML, for which there
        are standard schema languages, but they may also use JSON or any other format, and the
        authoritative description for a given media type may be a document available in HTML, text,
        PDF, or some other format. Some media types are shared among multiple specifications, other
        media types have no authoritative description. Two media types may represent the same
        properties in XML and JSON respectively. Because of this, media type descriptions in RSDL
        allow reference to any available schema or description in formats we use, but they do not
        require a schema or a description, and a media type can be documented directly in its
          <code class="code">documentation</code> element. Because some services need both XML and JSON
        representations, we also allow RSDL descriptions to avoid duplication by specifying
        properties in resources rather than in the media types, and documenting the manner in which
        properties are mapped to the corresponding <code class="code">+xml</code> or <code class="code">+json</code> media
        types. This is described in the section on <code class="code">resources</code>. </p><p>The following schema fragment describes RSDL media types. </p><pre class="programlisting">
media-types = element media-types { documentation?, media-type* }
media-type = element media-type { id?, name, documentation?, description* }
media-type-ref = attribute media-type-ref { xsd:IDREF }

description = element description { type, href, documentation? }
type = attribute type { "rnc" | "rng" | "xsd" | "JSONSchema" | "sedola" | "text" | "html" }
href = attribute href { xsd:anyURI }        
      </pre><p>The <code class="code">type</code> attribute of a media type description refers to the language of
        the document referred to by the <code class="code">href</code> attribute. It can be an XML schema (in
        Relax-NG Compact Syntax (<code class="code">rnc</code>), Relax-NG (<code class="code">rng</code>), or W3C XML Schema
          (<code class="code">xsd</code>), a JSON Schema (<code class="code">JSONSchema</code>), a human readable description
        (in <code class="code">text</code> or <code class="code">html</code>), or Sedola (<code class="code">sedola</code>), an XML format
        that provides a structured description of a media type with cross-references into the
        document that defines it.<a href="#ftn.d5e139" class="footnote" name="d5e139"><sup class="footnote">[3]</sup></a>
      </p><p>Here are the media types for our example:</p><pre class="programlisting">
  &lt;media-types&gt;
    &lt;media-type id="med-document" name="application/vnd.example.document+xml"&gt;
      &lt;documentation&gt; The media type for the service described by this RSDL description.&lt;/documentation&gt;
      &lt;description href="example.com/mediatypes/documents.rnc" type="rnc"/&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-home-xml" name="application/home+xml"&gt;
      &lt;documentation&gt; Home Documents for HTTP Services: XML Syntax &lt;/documentation&gt;
      &lt;description href="http://tools.ietf.org/html/draft-wilde-home-xml-01.html" type="html"/&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-atom" name="application/atom+xml"&gt;
      &lt;documentation&gt; Atom feeds, updateable using AtomPub conventions, with feed paging.
      &lt;/documentation&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-html" name="text/html"&gt;
      &lt;documentation&gt; HTML documents. &lt;/documentation&gt;
    &lt;/media-type&gt;
  &lt;/media-types&gt;        
      </pre><p>Note that the <code class="code">media-type</code> for
          <code class="code">application/vnd.example.document+xml</code> provides both inline documentation and a
        schema, the <code class="code">media-type</code> for <code class="code">application/home+xml</code> provides inline
        documentation and a reference to an HTML page, and the <code class="code">media-type</code>s for
          <code class="code">application/atom+xml</code> and <code class="code">text/html</code> provide only brief inline
        documentation. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e152"></a>Resources</h3></div></div></div><p>Resources are at the heart of RSDL, which provides rich support for them. Here is a
        schema fragment for resources:</p><pre class="programlisting">
resources = element resources { id?, documentation?, resource* }
resource =
    element resource {
        documentation?,
        id,
        name,
        identity-provider-ref?,
        public?,
        status?,
        extends?,
        location?,
        properties?,
        links?,
        methods
    }
    
name = attribute name { text }
public = attribute public { "true" }

status = implementation-status?, design-status?
implementation-status =
    attribute implementation-status {
        "future" | "assigned" | "poc" | "partial" | "complete" | "passed"
    }
design-status =
    attribute design-status { "future" | "assigned" | "poc" | "partial" | "complete" | "approved" }
    
# A resource can extend an existing resource definition, inheriting what it already defines.
extends = attribute extends { xsd:IDREF }

location = element location { documentation?, (uri | (uri-template, var*)) }
uri = attribute uri { xsd:anyURI }
uri-template = attribute template { xsd:string }
# uri-parameter-ref indicates that the value is supplied by the client, using a URI parameter.
# If no uri-parameter-ref is present, the value is supplied by the server.
var = element var { documentation?, id?, name, uri?, uri-parameter-ref? }

properties = element properties { documentation?, property* }
property = element property { id?, name, documentation? }

links = element links { documentation?, link* }
link = element link { link-relation-ref, resource-ref, status?, documentation? }
resource-ref = attribute resource-ref { xsd:IDREF }
link-relation-ref = attribute link-relation-ref { xsd:anyURI }

methods = element methods { method* }
method = element method { id?, method-name, status?, request?, response? }
method-name = attribute name { http-method }

request = element request { documentation?, request-uri-parameters?, header-refs?, representation* }
response =
    element response { documentation?, response-status-codes?, header-refs?, representation* }
request-uri-parameters = element uri-parameters { request-uri-parameter }
request-uri-parameter = element uri-parameter { idref }
# When possible, avoid documenting status codes at the individual request level.
# If you have to, declare it globally and refer to it from the request.
response-status-codes =
    element status-codes {
        element status-code { ref }*
    }
# When possible, avoid documenting headers at the individual request level.
# If you have to, declare it globally and refer to it from the request.    
header-refs = element header-refs { documentation?, header-ref* }
header-ref = element header-ref { ref }
representation = element representation { documentation?, media-type-ref, entity? }
entity = attribute entity { text }
http-method = "GET" | "PUT" | "HEAD" | "POST" | "DELETE" | "TRACE" | "OPTIONS" | "CONNECT" | "PATCH"    
      </pre><p>Let's look at three resources from our example. The home resource for our example is an
        XML Home Document. In our own designs, we frequently use <a class="xref" href="#json-home">JSON Home Documents</a>, or
          <a class="xref" href="#xml-home">XML Home Documents</a> as the home document for a resource, but Atom feeds are also
        popular as home documents, and some services use a single application-domain object as the
        home document. Here is the RSDL description of an XML Home Document resource:</p><pre class="programlisting">
    &lt;resource id="res-home" name="home"&gt;
      &lt;location uri="/"/&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-self" resource-ref="res-documents"/&gt;      
        &lt;link link-relation-ref="rel-documents" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-about" resource-ref="res-about"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-home-xml" entity="resources"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;</pre><p>In this example, the methods and the links define the interface for the resource. Like
        the name of a service, the name of a resource is not part of the interface. Neither is the
          <code class="code">id</code>, it exists to allow cross-reference in a RSDL description. Nor is the
          <code class="code">location</code> element, which is optional.</p><p>A method specifies an HTTP method name that is supported for the resource in which it
        contains and the <code class="code">request</code> or <code class="code">response</code> associated with the method.
        In the above example, a <code class="code">GET</code> method results in a response that contains the
        representation of an XML Home Document, which was specified in the media types we discussed
        in an earlier section.</p><p>The links each define a transition to another resource. Each link contains a reference
        to a globally declared link relation, discussed later, and the resource to which the link
        resolves. One link element is created for each (<code class="code">link-relation-ref</code>,
          <code class="code">resource-ref</code>) pair. Note that RSDL allows links to be defined only in terms
        of link relations, not in terms of the structure of URIs. A link refers to a resource, not a
        representation; to find the available representations for a resource, look at the resource
        and see what it returns for <code class="code">GET</code>. In this example, the second link contains a
        reference to a globally declared link relation with the id <code class="code">rel-documents</code>, which
        is defined as follows: </p><pre class="programlisting">
      &lt;link-relation id="rel-documents" name="identifiers.example.com/linkrel/documents"/&gt;
      </pre><p>It also contains a reference to the resource with the id <code class="code">res-documents</code>, an
        Atom feed which is described below:</p><pre class="programlisting">
    &lt;resource id="res-documents" name="documents"&gt;
      &lt;location uri="/documents"/&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-self" resource-ref="res-documents"/&gt;
        
        &lt;link link-relation-ref="rel-first" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-next" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-last" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-previous" resource-ref="res-documents"/&gt;

        &lt;link link-relation-ref="rel-alternate" resource-ref="res-document"&gt;
          &lt;documentation&gt; 
            In an ATOM feed, we use the alternate link relation to indicate the member
            type. 
          &lt;/documentation&gt;
        &lt;/link&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-atom" entity="atom:feed"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
        &lt;method name="POST"&gt;
          &lt;request&gt;
            &lt;documentation&gt;Creates a document&lt;/documentation&gt;          
            &lt;representation media-type-ref="med-document" entity="document"/&gt;
          &lt;/request&gt;
          &lt;response&gt;
            &lt;documentation&gt;Returns the newly created document&lt;/documentation&gt;          
            &lt;representation media-type-ref="med-document" entity="document"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;
  </pre><p>This resource is an Atom feed that supports paging and adding new documents. The
        following link relations refer to the IANA standard link relations used for paging:</p><pre class="programlisting">
&lt;link-relation id="rel-first" name="first"/&gt;
&lt;link-relation id="rel-last" name="last"/&gt;
&lt;link-relation id="rel-next" name="next"/&gt;
&lt;link-relation id="rel-previous" name="previous"/&gt;
   </pre><p>Because this resource supports AtomPub, it has a POST method. Both the request and the
        response refer to the <code class="code">document</code> entity, as defined by the media type with the
        identifier <code class="code">med-document</code>.</p><pre class="programlisting">      
&lt;method name="POST"&gt;
    &lt;request&gt;
        &lt;documentation&gt;Creates a document&lt;/documentation&gt;
        &lt;representation media-type-ref="med-document" entity="document"/&gt;
    &lt;/request&gt;
    &lt;response&gt;
        &lt;documentation&gt;Returns the newly created document&lt;/documentation&gt;
        &lt;representation media-type-ref="med-document" entity="document"/&gt;
    &lt;/response&gt;
&lt;/method&gt;  
   </pre><p>This resource uses the IANA standard <code class="code">alternate</code> link relation to describe
        the type of the collection's members:</p><pre class="programlisting">
&lt;link link-relation-ref="rel-alternate" resource-ref="res-document"&gt;
   &lt;documentation&gt; 
       In an ATOM feed, we use the alternate link relation to indicate the member type. 
   &lt;/documentation&gt;
&lt;/link&gt; 
      </pre><p>Here is the resource that corresponds to the member type:</p><pre class="programlisting">
    &lt;resource id="res-document" name="document"&gt;
      &lt;location template="/document/{oid}"&gt;
        &lt;var name="oid"&gt;
          &lt;documentation&gt; Identifier for the document. &lt;/documentation&gt;
        &lt;/var&gt;
      &lt;/location&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-self" resource-ref="res-document"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-document" entity="res-document"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;

        &lt;method name="PUT"&gt;
          &lt;request&gt;
            &lt;representation media-type-ref="med-document" entity="res-document"/&gt;
          &lt;/request&gt;
        &lt;/method&gt;

        &lt;method name="DELETE"/&gt;

      &lt;/methods&gt;
    &lt;/resource&gt;
    </pre><p>Sometimes a resource has different authentication constraints than other resources in
        the same service. In our example, the <code class="code">about</code> resource does not require
        authentication, even though the service has specified authentication globally. This is
        expressed using the <code class="code">public=true</code> attribute:</p><pre class="programlisting">
&lt;resource id="res-about" name="about" public="true"&gt;
    &lt;documentation&gt;An HTML page describing the service.&lt;/documentation&gt;
    &lt;location uri="/about"/&gt;
    &lt;methods&gt;
        &lt;method name="GET"&gt;
            &lt;response&gt;
                &lt;representation media-type-ref="med-html" entity="html"/&gt;
            &lt;/response&gt;
        &lt;/method&gt;
    &lt;/methods&gt;
&lt;/resource&gt;
      </pre><p>The opposite situation is also common - a service may need no authentication on most
        resources, but require authentication for specific resources such as a payment resource, or
        perhaps one resource uses a different kind of authentication from others. Both can be
        expressed using an <code class="code">identity-provider-ref</code> attribute on the resource, specifying
        the authentication to be used.</p><p>The <code class="code">location</code> element is always optional, and is not part of the client
        interface. It specifies a location URI or a URI template that describes the format of a URI
        that resolves to a given resource. Here are two location elements that illustrate both
        possibilities:</p><pre class="programlisting">
&lt;location uri="/about"/&gt;            
        </pre><pre class="programlisting">
&lt;location template="/document/{oid}"&gt;
    &lt;var name="oid"&gt;
        &lt;documentation&gt; Identifier for the document. &lt;/documentation&gt;
    &lt;/var&gt;
&lt;/location&gt;  
        </pre><p>A variable in a URI template sometimes corresponds to a URI parameter that should be
        provided by the client. This can be expressed by adding a <code class="code">uri-parameter-ref</code>
        attribute to the variable:</p><pre class="programlisting">
&lt;location template="/document/{oid}"&gt;
    &lt;var name="oid" uri-parameter-ref="par-oid"/&gt;
&lt;/location&gt;  
        </pre><p>URI parameters can also be specified in a request. For instance, if we want to allow an
        Atom feed to be sorted, we could provide a URI parameter to specify the sort in the
          <code class="code">GET</code> request:</p><pre class="programlisting">
&lt;method name="GET"&gt;
    &lt;request&gt;
        &lt;uri-parameters&gt;
            &lt;uri-parameter ref="par-sortby"/&gt; 
        &lt;/uri-parameters&gt;            
    &lt;/request&gt;
    &lt;response&gt;
        &lt;representation media-type-ref="med-atom" entity="feed"/&gt;
    &lt;/response&gt;
&lt;/method&gt;        
        </pre><p>On a <code class="code">resource</code> element, the <code class="code">extends</code> attribute allows one
        resource to inherit all items from an existing resource and extend it by adding further
        items or override existing items. For instance, the following description creates an
          <code class="code">invoice</code> resource that inherits everything found in a <code class="code">document</code>
        resource, and adds a link to represent the customer for an invoice:</p><pre class="programlisting">
&lt;resource id="res-invoice" name="invoice" extends="res-document"&gt;
  &lt;links&gt;
    &lt;link link-relation-ref="rel-customer" resource-ref="res-customer"/&gt;
  &lt;/links&gt;  
&lt;/resource&gt;
        </pre><p>Status attributes on a <code class="code">resource</code> element can be used to track both the
        design status and the implementation status:</p><pre class="programlisting">      
&lt;resource id="res-document" name="document" design-status="approved" implementation-status="poc"&gt;      
      </pre><p><code class="code">property</code> elements can be used to specify properties of a resource. This is
        typically done when more than one media type represents the same resource, in order to
        minimize redundant specification. In this case, the media types should describe how a
        property is mapped to its representation. Note that property elements are defined purely by
        documentation, they do not have a standard type system or a standard set of
        datatypes.</p><pre class="programlisting">
&lt;properties&gt;
    &lt;property name="expiration"&gt;
        &lt;documentation&gt;A date, representing the expiration date of the document.&lt;/documentation&gt;
    &lt;/property&gt;   
&lt;/properties&gt;        
      </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e215"></a>Link Relations</h3></div></div></div><p>Link relations are declared globally. We recommend that even IANA standard link
        relations be documented for a service, because there are many standard link relations, and
        their meaning is not completely specified, their meaning needs to be specified concretely
        for a given service. Link relations are declared globally and referred to from individual
        resources. If the name of a link relation is not registered with IANA, its name should be a
        URI, such as <code class="code">identifiers.example.com/linkrel/documents</code>.</p><pre class="programlisting">
  &lt;link-relations&gt;
    &lt;documentation&gt; Link relations used in the media-type. IANA link relations can be found &lt;ref
        uri="http://www.iana.org/assignments/link-relations/link-relations.xml"&gt;here&lt;/ref&gt;. Non-IANA
      link relations will be registered on identifiers.example.com. &lt;/documentation&gt;

    &lt;link-relation id="rel-about" name="about"/&gt;
    &lt;link-relation id="rel-alternate" name="alternate"/&gt;
    &lt;link-relation id="rel-self" name="self"/&gt;
    &lt;link-relation id="rel-edit" name="edit"/&gt;
    &lt;link-relation id="rel-first" name="first"/&gt;
    &lt;link-relation id="rel-last" name="last"/&gt;
    &lt;link-relation id="rel-next" name="next"/&gt;
    &lt;link-relation id="rel-previous" name="previous"/&gt;
    &lt;link-relation id="rel-parent" name="parent"/&gt;

    &lt;link-relation id="rel-documents" name="identifiers.example.com/linkrel/documents"/&gt;

  &lt;/link-relations&gt;        
      </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e220"></a>Headers</h3></div></div></div><p>Headers are declared globally. We recommend that even standard HTTP headers be
        documented for a service, so that clients know what is required.</p><pre class="programlisting">
  &lt;headers&gt;
    &lt;header id="hea-authenticate" name="WWW-Authenticate" type="request"/&gt;
  &lt;/headers&gt;        
      </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e224"></a>Authentication</h3></div></div></div><p>Authentication mechanisms and identity providers are declared globally. Here is the
        schema fragment for authentication:</p><pre class="programlisting">
authentication = element authentication { mechanism*,  identity-provider* }
mechanism = element mechanism { id?, name, authentication-type, documentation?, scheme* }
mechanism-ref = attribute mechanism-ref { xsd:IDREF }
identity-provider = element identity-provider { id, mechanism-ref }
authentication-type = attribute authentication-type { text }
scheme = element scheme { id?, name, documentation?, scheme-parameter* }
scheme-parameter = element parameter { id?, name, documentation? }        
        </pre><p>Here is the authentication used in our example:</p><pre class="programlisting">
  &lt;authentication&gt;
    &lt;mechanism id="aut-http" name="HTTP Authentication" authentication-type="rfc2617"&gt;
      &lt;documentation&gt; 
        We use HTTP Authentication as defined in &lt;ref uri="http://tools.ietf.org/html/rfc2617"&gt;RFC 2617&lt;/ref&gt; 
        with custom schemes. If an unauthenticated user tries to access a protected resource, a 
        &lt;ref status-code="sta-unauthorized"/&gt; status is returned, along with one or more 
        &lt;ref header="hea-authenticate"/&gt; headers, each of which contains an authentication 
        &lt;html:em&gt;challenge&lt;/html:em&gt;. The challenges consist of a scheme followed by one or more parameters. 
      &lt;/documentation&gt;
      &lt;scheme name="basic"&gt;
        &lt;parameter name="realm"/&gt;
      &lt;/scheme&gt;
      &lt;identity-provider id="idp" mechanism-ref="aut-http"/&gt;       
    &lt;/mechanism&gt;
  &lt;/authentication&gt;        
      </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e230"></a>Status Codes</h3></div></div></div><p>Status codes are declared globally. In order to avoid tight coupling, we do not provide
        a direct mechanism for documenting status codes for an individual request (the documentation
        for a request can refer to globally declared status codes as necessary). We recommend that a
        service document any uncommon status codes or uncommon uses of status codes at the service
        level so that clients can be prepared to handle them. Details of error conditions can be
        reported with <a class="xref" href="#draft-nottingham-http-problem-04">Problem Details for HTTP APIs</a> conventions using the
          <code class="code">http-problem</code> element, as specified in the schema</p><pre class="programlisting">
status-codes = element status-codes { documentation?, status-code* }
status-code = element status { code, id, documentation?, http-problem? }
status-code-ref = attribute ref { xsd:IDREF }
code = attribute code { HTTP-status-enum }
HTTP-status-enum =
    "100"
    | "101"
    | "102"
    | "200"
    | "201"
    | "203"
    | "204"
    | "205"
    | "206"
    | "207"
    | "208"
    | "301"
    | "302"
    | "303"
    | "304"
    | "305"
    | "306"
    | "307"
    | "308"
    | "400"
    | "401"
    | "402"
    | "403"
    | "404"
    | "405"
    | "406"
    | "407"
    | "408"
    | "409"
    | "410"
    | "411"
    | "412"
    | "413"
    | "414"
    | "415"
    | "416"
    | "417"
    | "418"
    | "420"
    | "422"
    | "423"
    | "424"
    | "425"
    | "426"
    | "428"
    | "429"
    | "431"
    | "444"
    | "449"
    | "450"
    | "451"
    | "494"
    | "495"
    | "496"
    | "497"
    | "499"
    | "500"
    | "501"
    | "502"
    | "503"
    | "504"
    | "505"
    | "506"
    | "507"
    | "508"
    | "509"
    | "510"
    | "511"
    | "598"
    | "599"        
      </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e236"></a>URI Parameters</h3></div></div></div><p>URI parameters are declared globally, and can be referenced from <code class="code">request</code>s
        in <code class="code">method</code>s.</p><pre class="programlisting">
  &lt;uri-parameters&gt;
    &lt;uri-parameter id="par-sortby" name="sortby" datatype="string"&gt;
      &lt;documentation&gt;
        Specifies a sort order for the collection.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
  &lt;/uri-parameters&gt;         
      </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e242"></a>Documentation Modules</h3></div></div></div><p>The content allowed within a <code class="code">documentation</code> element is defined by a separate
        module that is imported.</p><pre class="programlisting">
include "documentation.rnc"        
      </pre><p>We have defined modules <a class="link" href="#appx-html-subset" title="B.&nbsp;HTML module for RSDL Documentation">for HTML</a> and <a class="link" href="#appx-docbook-subset" title="C.&nbsp;DocBook module for RSDL Documentation">for DocBook</a>. A <code class="code">documentation</code> element can
        have a title, which is treated much like a section header, and an <code class="code">inline</code>
        attribute. Documentation that contains code examples, tables, multiple sections, or large
        amounts of text can be marked <code class="code">inline="false"</code> so that a stylesheet can convert
        it to endnotes, a popup window, or whatever representation is appropriate to the format the
        stylesheet produces.</p><p>Here is the first part of the HTML documentation module:</p><pre class="programlisting">
namespace html = "http://www.w3.org/1999/xhtml/"
namespace docbook = "http://docbook.org/ns/docbook"

documentation = element documentation { inline?, doc-title?, html }

inline = attribute inline { ( "true" | "false" ) }
doc-title = element title { text }

html =  html-content*
html-content = (html-element | text | ref)
html-element = element html:* { html-attribute*, html-content* }
html-attribute = attribute * { text? }</pre><p>Documentation frequently needs to refer to items from the RSDL description itself, so we
        support typed references interspersed with documentation:</p><pre class="programlisting">
ref = element ref {
  (  attribute idref { xsd:IDREF }
  | attribute uri { xsd:anyURI }
  | attribute media-type { xsd:IDREF }
  | attribute header { xsd:IDREF }
  | attribute mechanism { xsd:IDREF }
  | attribute identity-provider { xsd:IDREF }
  | attribute scheme { xsd:IDREF }
  | attribute scheme-parameter { xsd:IDREF }
  | attribute status-code { xsd:IDREF }
  | attribute uri-parameter { xsd:IDREF }
  | attribute resources { xsd:IDREF }
  | attribute resource { xsd:IDREF }
  | attribute var { xsd:IDREF }
  | attribute property { xsd:IDREF } 
  | attribute header { xsd:IDREF } 
  | attribute method { xsd:IDREF } 
  ),
  text?  # Uses the name of the referred item if not provided
}       
      </pre><p>We have already seen an example that uses <code class="code">ref</code> elements in the
          <code class="code">documentation</code> element for a <code class="code">mechanism</code>:</p><pre class="programlisting">
  &lt;authentication&gt;
    &lt;mechanism id="aut-http" name="HTTP Authentication" authentication-type="rfc2617"&gt;
      &lt;documentation&gt; 
        We use HTTP Authentication as defined in &lt;ref uri="http://tools.ietf.org/html/rfc2617"&gt;RFC 2617&lt;/ref&gt; 
        with custom schemes. If an unauthenticated user tries to access a protected resource, a 
        &lt;ref status-code="sta-unauthorized"/&gt; status is returned, along with one or more 
        &lt;ref header="hea-authenticate"/&gt; headers, each of which contains an authentication 
        &lt;html:em&gt;challenge&lt;/html:em&gt;. The challenges consist of a scheme followed by one or more parameters. 
      &lt;/documentation&gt;
      &lt;scheme name="basic"&gt;
        &lt;parameter name="realm"/&gt;
      &lt;/scheme&gt;
      &lt;identity-provider id="idp" mechanism-ref="aut-http"/&gt;      
    &lt;/mechanism&gt;
  &lt;/authentication&gt;        
        </pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e262"></a>Initial Experience</h2></div></div></div><p>RSDL is quite new. We have recently started using it for some REST projects in the
      Information Intelligence Group at EMC Corporation. In this section, we would like to share our
      experiences so far.</p><p>We have found RSDL a valuable teaching tool in the hands of a teacher who is comfortable
      editing XML. On two projects, one of the authors was involved with an early design that was
      having difficulty ramping up the design, and responded by editing a RSDL description on a
      shared screen during a phone call with an engineer from the project. In each case, it was easy
      to copy similar designs from existing RSDL descriptions and modify them, then provide the RSDL
      description to the engineer as an initial skeleton for the design. With a standard description
      language, we believe we will be able to grow a library of common REST design patterns that can
      be copied and modified to design a REST interface.</p><p>Before RSDL, we maintained our REST specifications largely in Wikis, and a single design
      was frequently distributed across many Wiki pages. As a specification matured, it was
      difficult to keep these pages in sync, with accurate cross-references. More than one page
      might purport to represent the same design, different pages might represent the same
      information in more than one way, and the Wiki pages did little to enforce REST conventions.
      RSDL makes it much easier to version a design. By checking a RSDL description into source code
      control, reviewers can see changes in the design specification along with code changes, and it
      is always possible to retrieve the design specification that corresponds to a particular
      version of the code.</p><p>Before RSDL, user documentation was created from information in these Wikis, initially by
      converting it to DocBook. RSDL allows this to be done using an XSLT transformation. We expect
      to integrate RSDL into our documentation tool chain. </p><p>While the structure of a URI should not be provided to clients, we have found that it is
      important for actually implementing a service. For instance, if the URI structure is included,
      skeleton code could be generated to create stubs that can be used to implement a server, using
      a REST framework such as JAX-RS for Java. </p><p>We have been experimenting with REST clients that perform QA testing using a RSDL
      description. One of us wrote a REST client that takes a RSDL file as input and issues HTTP
      requests, navigating the service, and ensuring that each response corresponds to the RSDL
      description and reporting any deviations. In effect, the test client infers the design from
      the actual implementation, and compares it to the design specified by the RSDL description. As
      a result, we found missing resources and links in the implementation, and resources that had
      been implemented but not specified, and methods that should not be available on a resource. We
      also found code that did not properly handle edge cases for data provided via URI templates
      (in the future, we may develop a fuzzer to test for this kind of problem). We have used this
      test client in our build process. When a new resource is implemented, or an existing one is
      changed, we can test to see if the RSDL was also updated appropriately. If not, the build
      fails. Because both the build process and the documentation are synchronized with the
      specification, we can guarantee that the specification, the code, and the documentation are
      kept in sync.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e270"></a>Future Work</h2></div></div></div><p>This section describes some tools that have not yet been written, or in very early stages,
      that we are considering implementing.</p><p>RSDL Lint is an XSLT transform that checks a RSDL description for internal consistency. In
      its current form, it ensures that an <code class="code">IDREF</code> refers to an element of the
      appropriate type, ensures that identifiers follow our in-house standards, screens for media
      types that we do not allow in our interfaces, and warns of items that cannot be reached from
      the home resource by navigation. It can be integrated into the build process, raising either
      errors or warnings. We expect to expand the functionality of RSDL Lint significantly.</p><p>When documenting REST APIs, we often want to capture the results of concrete scenarios
      running on a server and show the entire sequence of calls, including the URIs, requests, and
      responses. We are writing a tool executes a message flow using an XML vocabulary that refers
      to the components of a RSDL description. This tool generates HTML to document the requests and
      responses of the message flow. As the specification evolves, or the data in the server
      changes, the message flow can be run again to create up-to-date documentation. </p><p>We plan to experiment with domain-specific editors and browsers for RSDL, including the
      ability to select templates that implement standard RESTful design patterns so that they can
      be modified.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e277"></a>Conclusions</h2></div></div></div><p>RSDL provides a formal notation that can be used to think more clearly about the model for
      a RESTful service. It is an XML vocabulary designed for loosely-coupled, hypermedia-driven
      RESTful design, and supports the rich structure and cross references of a REST service. We
      find it useful as a teaching tool, a design tool, and a way to represent known design patterns
      that can be copied and modified in a new RESTful service. RSDL can be used to generate
      documentation in various formats. </p><p>As a machine-readable description, RSDL can be used for software-based testing of design
      consistency constraints, dynamic testing of the implementation based on the design, and in a
      variety of other tools. These tools can be integrated with the build process, identifying
      mismatches between the specification and the implementation. By versioning a RSDL description
      together with source code, reviewers can see changes in the design specification along with
      code changes, and it is always possible to retrieve the design specification that corresponds
      to a particular version of the code.</p><p></p></div><div class="appendix"><h2 class="title" style="clear: both"><a name="appx-rsdl.rnc"></a>A.&nbsp;RSDL Schema</h2><p>The following schema, in RELAX-NG compact syntax, defines RSDL.</p><pre class="programlisting">

default namespace rsdl = "http://identifiers.emc.com/rsdl"

include "documentation.rnc"

start = service
service =
    element service {
        id?,
        name,
        identity-provider-ref?,
        documentation?,
        service-start,
        media-types,
        resources,
        link-relations?,
        headers?,
        authentication?,
        status-codes?,
        uri-parameters?
    }
    
id = attribute id { xsd:ID }
idref = attribute ref { xsd:IDREF }

service-start = element start { idref }
identity-provider-ref = attribute identity-provider-ref { xsd:IDREF }

media-types = element media-types { documentation?, media-type* }
media-type = element media-type { id?, name, documentation?, description* }
media-type-ref = attribute media-type-ref { xsd:IDREF }
description = element description { type, href, documentation? }
type = attribute type { "rnc" | "rng" | "xsd" | "JSONSchema" | "sedola" | "text" | "html" }
href = attribute href { xsd:anyURI }

resources = element resources { id?, documentation?, resource* }
resource =
    element resource {
        documentation?,
        id,
        name,
        identity-provider-ref?,
        public?,
        status?,
        extends?,
        location?,
        properties?,
        links?,
        methods
    }
    
name = attribute name { text }
public = attribute public { "true" }

status = implementation-status?, design-status?
implementation-status =
    attribute implementation-status {
        "future" | "assigned" | "poc" | "partial" | "complete" | "passed"
    }
design-status =
    attribute design-status { "future" | "assigned" | "poc" | "partial" | "complete" | "approved" }
# A resource can extend an existing resource definition, inheriting what it already defines.

extends = attribute extends { xsd:IDREF }

location =
    element location {
        documentation?,
        (uri | (uri-template, var*))
    }
uri-template = attribute template { xsd:string }
# URI refers to a link relation. If absent, it is a local link relation, identified by name.
# uri-parameter-ref indicates that the value is supplied by the client, using a URI parameter.
#    If no uri-parameter-ref is present, the value is supplied by the server.
var = element var { documentation?, id?, name, uri?, uri-parameter-ref? }

properties = element properties { documentation?, property* }
property = element property { id?, name, documentation? }

links = element links { documentation?, link* }
link = element link { link-relation-ref, resource-ref, status?, documentation? }
resource-ref = attribute resource-ref { xsd:IDREF }
link-relation-ref = attribute link-relation-ref { xsd:anyURI }

methods = element methods { method* }
method = element method { id?, method-name, status?, request?, response? }
method-name = attribute name { http-method }
request = element request { documentation?, request-uri-parameters?, header-refs?, representation* }
response =
    element response { documentation?, response-status-codes?, header-refs?, representation* }
request-uri-parameters = element uri-parameters { request-uri-parameter }
request-uri-parameter = element uri-parameter { idref }
response-status-codes =
    element status-codes {
        element status-code { ref }*
    }

header-refs = element header-refs { documentation?, header-ref* }
header-ref = element header-ref { ref }

representation = element representation { documentation?, media-type-ref, entity? }
entity = attribute entity { text }

http-method = "GET" | "PUT" | "HEAD" | "POST" | "DELETE" | "TRACE" | "OPTIONS" | "CONNECT" | "PATCH"

link-relations = element link-relations { documentation?, link-relation* }
link-relation = element link-relation { documentation?, id, status, link-relation-name, href? }
link-relation-name = attribute name { xsd:anyURI }

headers = element headers { header* }
header = element header { id?, name, header-type, documentation? }
header-type = attribute type { "request" | "response" | "general" | "entity" }

authentication = element authentication { mechanism*, identity-provider? }
mechanism = element mechanism { id?, name, authentication-type, documentation?, scheme* }
mechanism-ref = attribute mechanism-ref { xsd:IDREF }
identity-provider = element identity-provider { id, mechanism-ref }
authentication-type = attribute authentication-type { text }
scheme = element scheme { id?, name, documentation?, scheme-parameter* }
scheme-parameter = element parameter { id?, name, documentation? }

status-codes = element status-codes { documentation?, status-code* }
status-code = element status { code, id, documentation?, http-problem? }
status-code-ref = attribute ref { xsd:IDREF }
code = attribute code { HTTP-status-enum }
HTTP-status-enum =
    "100"
    | "101"
    | "102"
    | "200"
    | "201"
    | "203"
    | "204"
    | "205"
    | "206"
    | "207"
    | "208"
    | "301"
    | "302"
    | "303"
    | "304"
    | "305"
    | "306"
    | "307"
    | "308"
    | "400"
    | "401"
    | "402"
    | "403"
    | "404"
    | "405"
    | "406"
    | "407"
    | "408"
    | "409"
    | "410"
    | "411"
    | "412"
    | "413"
    | "414"
    | "415"
    | "416"
    | "417"
    | "418"
    | "420"
    | "422"
    | "423"
    | "424"
    | "425"
    | "426"
    | "428"
    | "429"
    | "431"
    | "444"
    | "449"
    | "450"
    | "451"
    | "494"
    | "495"
    | "496"
    | "497"
    | "499"
    | "500"
    | "501"
    | "502"
    | "503"
    | "504"
    | "505"
    | "506"
    | "507"
    | "508"
    | "509"
    | "510"
    | "511"
    | "598"
    | "599"

http-problem = element problem { problemType, title, detail, supportId, more }
problemType = element problemType { xsd:anyURI }
title = element title { text }
detail = element detail { text }
supportId = element supportId { xsd:anyURI }
more = element more { foreign-element* }
foreign-element = element * - rsdl:* { any-attribute*, (foreign-element* | text)* }
any-attribute = attribute * { text? }

uri-parameters = element uri-parameters { documentation?, uri-parameter* }
uri-parameter =
    element uri-parameter { id?, name, documentation, datatype, value-range?, default-value? }
uri-parameter-ref = attribute uri-parameter-ref { xsd:IDREF }

datatype =
    attribute datatype {
        "string"
        | "boolean"
        | "decimal"
        | "float"
        | "double"
        | "duration"
        | "dateTime"
        | "time"
        | "date"
        | "hexBinary"
        | "base64Binary"
        | "anyURI"
        | "integer"
        | "language"
        | "ID"
        | "IDREF"
        | "integer"
        | "long"
        | "short"
        | "byte"
    }

value-range = element value-range { text }
default-value = element default { text }

uri = attribute uri { xsd:anyURI }

# ref elements are used in the documentation modules
ref =
    element ref {
        ((attribute idref { xsd:IDREF }
          | attribute uri { xsd:anyURI }
          | attribute media-type { xsd:IDREF }
          | attribute header { xsd:IDREF }
          | attribute mechanism { xsd:IDREF }
          | attribute identity-provider { xsd:IDREF }
          | attribute scheme { xsd:IDREF }
          | attribute scheme-parameter { xsd:IDREF }
          | attribute status-code { xsd:IDREF }
          | attribute uri-parameter { xsd:IDREF }
          | attribute resources { xsd:IDREF }
          | attribute resource { xsd:IDREF }
          | attribute var { xsd:IDREF }
          | attribute property { xsd:IDREF }
          | attribute header { xsd:IDREF }
          | attribute method { xsd:IDREF }),
         text?)
        # Uses the name of the referred item if not provided
        
    }

    </pre></div><div class="appendix"><h2 class="title" style="clear: both"><a name="appx-html-subset"></a>B.&nbsp;HTML module for RSDL Documentation</h2><pre class="programlisting">
namespace html = "http://www.w3.org/1999/xhtml/"

documentation = element documentation { inline?, doc-title?, html }

inline = attribute inline { ( "true" | "false" ) }
doc-title = element title { text }

html =  html-content*
html-content = (html-element | text | ref)
html-element = element html:* { html-attribute*, html-content* }
html-attribute = attribute * { text? }      
    </pre></div><div class="appendix"><h2 class="title" style="clear: both"><a name="appx-docbook-subset"></a>C.&nbsp;DocBook module for RSDL Documentation</h2><pre class="programlisting">
namespace docbook = "http://docbook.org/ns/docbook"

documentation = element documentation { inline?, doc-title?, docbook }

inline = attribute inline { ( "true" | "false" ) }
doc-title = element title { text }

docbook =  docbook-content*
docbook-content = (docbook-element | text | ref)
docbook-element = element docbook:* { docbook-attribute*, docbook-content* }
docbook-attribute = attribute * { text? }
      
    </pre></div><div class="appendix"><h2 class="title" style="clear: both"><a name="appx-xslt-stylesheet"></a>D.&nbsp;An XSLT Stylesheet for RSDL</h2><p>The following stylesheet converts a RSDL description to an HTML page.</p><pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:html="http://www.w3.org/1999/xhtml/"
    xmlns:rsdl="http://identifiers.emc.com/rsdl"&gt;
  &lt;xsl:output method="html" encoding ="utf-8" indent="no"/&gt;
  &lt;xsl:strip-space elements="*"/&gt;

  &lt;xsl:key name="status" match="//rsdl:status-codes/rsdl:status" use="@code" /&gt;
    
  &lt;xsl:template match="/rsdl:service"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;&lt;xsl:call-template name="title"/&gt;&lt;/title&gt;
        &lt;xsl:call-template name="style"/&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div class="outline index"&gt;
          &lt;xsl:call-template name="index"/&gt;
        &lt;/div&gt;
        &lt;div class="outline reference"&gt;
          &lt;xsl:call-template name="reference"/&gt;
        &lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="title"&gt;
    &lt;xsl:value-of select="@name"/&gt; REST Service
  &lt;/xsl:template&gt;

  &lt;xsl:template name="style"&gt;
    &lt;style type="text/css"&gt;
      body { margin: 0; padding: 0 0 0 16em; }
      h1, h2 { color: Navy; }
      h3 { color: Blue; }
      table { border-collapse: collapse; margin-bottom: 1em; }
      th, td { border: 1px solid; padding: 0.35em; vertical-align: top; }
      th { color: White; background-color: CornflowerBlue; text-align: left; border-color: Black; }
      td { border-color: DarkBlue; }
      .outline { vertical-align: top; padding: 1em; }
      .index { position: fixed; top: 0; left: 0; width: 16em; height: 96%; overflow: auto; font-size: smaller; }
      .reference { height: 100%; overflow: auto; }
      div { overflow: scroll; }
      .homeResource { 
        font-weight: bold; 
        font-size: smaller; 
        background-color: Green; 
        color: Yellow; 
        padding: 0.3em;
        margin-left: 1em;
        border-radius: 1em; 
      }
      #hint { 
        display: none; 
        font-size: small; 
        font-weight: normal;
        white-space: nowrap; 
        background-color: LightYellow; 
        color: DimGrey;
        border: 1px solid DimGrey;
        border-radius: 0.5em;
        padding: 0.5em; 
        margin-right: 0.5em;
      }
      #full { color: Green; margin-right: 0.2em; }
      #full:hover ~ #hint { display: inline; }
      #no { color: Red; margin-right: 0.2em; }
      #no:hover ~ #hint { display: inline; }
      #partial { color: Coral; margin-right: 0.3em; }
      #partial:hover ~ #hint { display: inline; }
      .one-piece { white-space: nowrap; text-wrap: none; }
      .center { text-align: center; }
      .button { 
        background-color: LightGrey; 
        color: Black; 
        font-size: smaller;
        border: 1px solid DarkGrey; 
        border-radius: 0.35em; 
        padding: 0.35em;
        text-decoration: none;
      }
      .header-suffix { font-size: small; }
    &lt;/style&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="index"&gt;
    &lt;xsl:call-template name="index-resources"/&gt;
    &lt;xsl:call-template name="index-media-types"/&gt;
    &lt;xsl:call-template name="index-link-relations"/&gt;
    &lt;xsl:call-template name="index-uri-parameters"/&gt;
    &lt;xsl:call-template name="index-custom-headers"/&gt;
    &lt;xsl:call-template name="index-status-codes"/&gt;
    &lt;xsl:call-template name="index-authentication-mechanisms"/&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="index-resources"&gt;
    &lt;h3&gt;Resources&lt;/h3&gt;
    &lt;xsl:for-each select="//rsdl:resources/rsdl:resource"&gt;
      &lt;xsl:sort select="@name"/&gt;
      &lt;a class="item"&gt;
        &lt;xsl:attribute name="style"&gt;
          top: &lt;xsl:value-of select="4 + position()"/&gt;em;
        &lt;/xsl:attribute&gt;
        &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
         &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
      &lt;/a&gt;
      &lt;xsl:call-template name="home-resource"/&gt;
      &lt;br/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="home-resource"&gt;
	  &lt;xsl:if test="@id = /rsdl:service/@home-resource"&gt;
	    &lt;span class="homeResource"&gt;Home resource&lt;/span&gt;
	  &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="index-media-types"&gt;
    &lt;h3&gt;Media Types&lt;/h3&gt;
    &lt;xsl:for-each select="//rsdl:media-types/rsdl:media-type"&gt;
      &lt;xsl:sort select="@name"/&gt;
      &lt;a class="item"&gt;
        &lt;xsl:attribute name="style"&gt;
          top: &lt;xsl:value-of select="4 + position()"/&gt;em;
        &lt;/xsl:attribute&gt;
        &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
         &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
      &lt;/a&gt;
      &lt;br/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template name="index-link-relations"&gt;
    &lt;h3&gt;Link Relations&lt;/h3&gt;
    &lt;xsl:for-each select="//rsdl:link-relations/rsdl:link-relation"&gt;
      &lt;xsl:sort select="@name"/&gt;
      &lt;a class="item"&gt;
        &lt;xsl:attribute name="style"&gt;
          top: &lt;xsl:value-of select="4 + position()"/&gt;em;
        &lt;/xsl:attribute&gt;
        &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
         &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
      &lt;/a&gt;
      &lt;br/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template name="index-authentication-mechanisms"&gt;
    &lt;xsl:if test="//rsdl:authentication/rsdl:uri-mechanism"&gt;
      &lt;h3&gt;Authentication Mechanisms&lt;/h3&gt;
      &lt;xsl:for-each select="//rsdl:authentication/rsdl:mechanism"&gt;
        &lt;xsl:sort select="@name"/&gt;
        &lt;a class="item"&gt;
          &lt;xsl:attribute name="style"&gt;
            top: &lt;xsl:value-of select="4 + position()"/&gt;em;
          &lt;/xsl:attribute&gt;
          &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
           &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
        &lt;/a&gt;
        &lt;br/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template name="index-status-codes"&gt;
    &lt;xsl:if test="//rsdl:status-codes/rsdl:status"&gt;
      &lt;h3&gt;Status Codes&lt;/h3&gt;
      &lt;xsl:for-each select="//rsdl:status-codes/rsdl:status"&gt;
        &lt;xsl:sort select="@code"/&gt;
        &lt;a class="item"&gt;
          &lt;xsl:attribute name="style"&gt;
            top: &lt;xsl:value-of select="4 + position()"/&gt;em;
          &lt;/xsl:attribute&gt;
          &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
           &lt;code&gt;&lt;xsl:value-of select="@code"/&gt;&lt;/code&gt;
        &lt;/a&gt;
        &lt;br/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template name="index-custom-headers"&gt;
    &lt;xsl:if test="//rsdl:custom-headers/rsdl:custom-header"&gt;
      &lt;h3&gt;Headers&lt;/h3&gt;
      &lt;xsl:for-each select="//rsdl:custom-headers/rsdl:custom-header"&gt;
        &lt;xsl:sort select="@name"/&gt;
        &lt;a class="item"&gt;
          &lt;xsl:attribute name="style"&gt;
            top: &lt;xsl:value-of select="4 + position()"/&gt;em;
          &lt;/xsl:attribute&gt;
          &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
           &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
        &lt;/a&gt;
        &lt;br/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template name="index-uri-parameters"&gt;
    &lt;xsl:if test="//rsdl:uri-parameters/rsdl:uri-parameter"&gt;
      &lt;h3&gt;URI Parameters&lt;/h3&gt;
      &lt;xsl:for-each select="//rsdl:uri-parameters/rsdl:uri-parameter"&gt;
        &lt;xsl:sort select="@name"/&gt;
        &lt;a class="item"&gt;
          &lt;xsl:attribute name="style"&gt;
            top: &lt;xsl:value-of select="4 + position()"/&gt;em;
          &lt;/xsl:attribute&gt;
          &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
           &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
        &lt;/a&gt;
        &lt;br/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="reference"&gt;
    &lt;h1&gt;&lt;xsl:call-template name="title"/&gt;&lt;/h1&gt;
    &lt;xsl:call-template name="resources"/&gt;
    &lt;xsl:call-template name="media-types"/&gt;
    &lt;xsl:call-template name="link-relations"/&gt;
    &lt;xsl:call-template name="uri-parameters"/&gt;
    &lt;xsl:call-template name="custom-headers"/&gt;
    &lt;xsl:call-template name="status-codes"/&gt;
    &lt;xsl:call-template name="authentication-mechanisms"/&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="resources"&gt;
    &lt;h2&gt;Resources&lt;/h2&gt;
    &lt;xsl:for-each select="//rsdl:resource"&gt;
      &lt;xsl:sort select="@name"/&gt;
      &lt;hr/&gt;
      &lt;h3&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
        &lt;/a&gt;
        &lt;xsl:call-template name="implemented"/&gt;
        &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
        &lt;xsl:call-template name="home-resource"/&gt;
      &lt;/h3&gt;
      &lt;xsl:apply-templates select="rsdl:documentation"/&gt;
      &lt;xsl:call-template name="authentication"/&gt;
      &lt;xsl:apply-templates select="*[local-name() != 'methods' and local-name() != 'documentation']"/&gt;
      &lt;xsl:call-template name="methods"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="authentication"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="/service/@identity-provider-ref and @public = 'true'"&gt;
        &lt;xsl:call-template name="no-authentication"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@identity-provider-ref"&gt;
        &lt;xsl:call-template name="identity-provider"&gt;
          &lt;xsl:with-param name="id" select="@identity-provider-ref"/&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="/service/@identity-provider-ref"&gt;
        &lt;xsl:variable name="id" select="/service/@identity-provider-ref"/&gt;
        &lt;h4&gt;Authentication&lt;/h4&gt;
        &lt;p&gt;
          &lt;xsl:apply-templates select="//authentication/identity-provider[@id = $id]"/&gt;
        &lt;/p&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:call-template name="no-authentication"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="no-authentication"&gt;
    &lt;xsl:if test="//rsdl:authentication/rsdl:mechanism"&gt;
      &lt;h4&gt;Authentication&lt;/h4&gt;
      &lt;p&gt;This resource requires no authentication.&lt;/p&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="identity-provider"&gt;
    &lt;xsl:param name="id"/&gt;
    &lt;xsl:variable name="idp" select="//rsdl:authentication/rsdl:identity-provider[@id = $id]"/&gt;
    &lt;xsl:variable name="mechanismId" select="$idp/@mechanism-ref"/&gt;
    &lt;xsl:variable name="mechanism" select="//rsdl:authentication/rsdl:mechanism[@id = $mechanismId]"/&gt;
    &lt;h4&gt;Authentication&lt;/h4&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;th&gt;Mechanism&lt;/th&gt;
        &lt;th&gt;Identity Provider&lt;/th&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;
          &lt;a&gt;
            &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$mechanismId"/&gt;&lt;/xsl:attribute&gt;
            &lt;xsl:apply-templates select="$mechanism/@name"/&gt;
          &lt;/a&gt;
        &lt;/td&gt;
        &lt;td&gt;
          &lt;xsl:apply-templates select="$idp/rsdl:documentation"/&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/xsl:template&gt;
   
  &lt;xsl:template name="implemented"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@status = 'full'"&gt;
        &lt;span id="full"&gt;&amp;#x2714;&lt;/span&gt;&lt;span id="hint"&gt;Fully implemented&lt;/span&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@status = 'partial'"&gt;
        &lt;span id="partial"&gt;?&lt;/span&gt;&lt;span id="hint"&gt;Partially implemented&lt;/span&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;span id="no"&gt;&amp;#x2718;&lt;/span&gt;&lt;span id="hint"&gt;Not implemented&lt;/span&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template match="rsdl:documentation"&gt;
    &lt;xsl:apply-templates select="text()|*"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="rsdl:authentication"&gt;
    &lt;xsl:variable name="mechanism" select="@mechanism-ref"/&gt;
    &lt;h4&gt;Authentication&lt;/h4&gt;
    &lt;p&gt;
      &lt;a&gt;
        &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$mechanism"/&gt;&lt;/xsl:attribute&gt;
        &lt;xsl:value-of select="//rsdl:authentication/rsdl:mechanism[@id = $mechanism]/@name"/&gt;
      &lt;/a&gt;.&amp;#160; &lt;xsl:apply-templates select="*"/&gt;
    &lt;/p&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template match="*"&gt;
    &lt;xsl:element name="{local-name()}"&gt;
      &lt;xsl:apply-templates select="*|@*|text()"/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:template&gt;
      
  &lt;xsl:template match="text()"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="rsdl:ref"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@resource and ancestor::rsdl:resource/@id = @resource"&gt;
        &lt;code&gt;
          &lt;xsl:value-of select="@resource"/&gt;
        &lt;/code&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
		    &lt;xsl:choose&gt;
		      &lt;xsl:when test="@resource"&gt;
            &lt;xsl:variable name="id" select="@resource"/&gt;
            &lt;xsl:call-template name="ref-by-id"&gt;
              &lt;xsl:with-param name="id" select="$id"/&gt;
              &lt;xsl:with-param name="name" select="//rsdl:resources/rsdl:resource[@id = $id]/@name"/&gt;
            &lt;/xsl:call-template&gt;
		      &lt;/xsl:when&gt;
          &lt;xsl:when test="@status-code"&gt;
            &lt;xsl:variable name="id" select="@status-code"/&gt;
            &lt;xsl:call-template name="ref-by-id"&gt;
              &lt;xsl:with-param name="id" select="$id"/&gt;
              &lt;xsl:with-param name="name" select="//rsdl:status-codes/rsdl:status[@id = $id]/@code"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="@uri-parameter"&gt;
            &lt;xsl:variable name="id" select="@uri-parameter"/&gt;
            &lt;xsl:call-template name="ref-by-id"&gt;
              &lt;xsl:with-param name="id" select="$id"/&gt;
              &lt;xsl:with-param name="name" select="//rsdl:uri-parameters/rsdl:uri-parameter[@id = $id]/@name"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="@custom-header"&gt;
            &lt;xsl:variable name="id" select="@custom-header"/&gt;
            &lt;xsl:call-template name="ref-by-id"&gt;
              &lt;xsl:with-param name="id" select="$id"/&gt;
              &lt;xsl:with-param name="name" select="//rsdl:custom-headers/rsdl:custom-header[@id = $id]/@name"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="@mechanism"&gt;
            &lt;xsl:variable name="id" select="@mechanism"/&gt;
            &lt;xsl:call-template name="ref-by-id"&gt;
              &lt;xsl:with-param name="id" select="$id"/&gt;
              &lt;xsl:with-param name="name" select="//rsdl:authentication/rsdl:mechanism[@id = $id]/@name"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="@media-type"&gt;
            &lt;xsl:variable name="id" select="@media-type"/&gt;
            &lt;xsl:call-template name="ref-by-id"&gt;
              &lt;xsl:with-param name="id" select="$id"/&gt;
              &lt;xsl:with-param name="name" select="//rsdl:media-types/rsdl:media-type[@id = $id]/@name"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;
		      &lt;xsl:otherwise&gt;
            &lt;a&gt;
  		        &lt;xsl:attribute name="href"&gt;
  		          &lt;xsl:value-of select="@uri"/&gt;
  		        &lt;/xsl:attribute&gt;
  		        &lt;xsl:apply-templates select="*|text()"/&gt;
            &lt;/a&gt;
		      &lt;/xsl:otherwise&gt;
		    &lt;/xsl:choose&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="ref-by-id"&gt;
    &lt;xsl:param name="id"/&gt;
    &lt;xsl:param name="name"/&gt;
    &lt;a&gt;
      &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$id"/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="text()"&gt;
          &lt;xsl:apply-templates select="*|text()"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;code&gt;
            &lt;xsl:value-of select="$name"/&gt;
          &lt;/code&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/a&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="methods"&gt;
    &lt;xsl:if test="rsdl:methods/rsdl:method"&gt;
      &lt;xsl:variable name="showStatus" select="rsdl:methods/rsdl:method/@status"/&gt;
      &lt;h4&gt;Supported Methods&lt;/h4&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;xsl:if test="$showStatus"&gt;
            &lt;th&gt;Status&lt;/th&gt;
          &lt;/xsl:if&gt;
          &lt;th&gt;Name&lt;/th&gt;
          &lt;xsl:if test="rsdl:methods/rsdl:method/rsdl:request"&gt;
            &lt;th&gt;Request&lt;/th&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="rsdl:methods/rsdl:method/rsdl:response"&gt;
            &lt;th&gt;Response&lt;/th&gt;
          &lt;/xsl:if&gt;
        &lt;/tr&gt;
        &lt;xsl:for-each select="rsdl:methods//rsdl:method"&gt;
          &lt;tr&gt;
            &lt;xsl:if test="$showStatus"&gt;
              &lt;td class="center"&gt;
                &lt;xsl:call-template name="implemented"/&gt;
              &lt;/td&gt;
            &lt;/xsl:if&gt;
            &lt;td&gt;
              &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
            &lt;/td&gt;
            &lt;xsl:if test="../rsdl:method/rsdl:request"&gt;
              &lt;td&gt;
                &lt;xsl:apply-templates select="rsdl:request/*"/&gt;
              &lt;/td&gt;
            &lt;/xsl:if&gt;
            &lt;xsl:if test="../rsdl:method/rsdl:response"&gt;
              &lt;td&gt;
                &lt;xsl:apply-templates select="rsdl:response/*"/&gt;
              &lt;/td&gt;
            &lt;/xsl:if&gt;
          &lt;/tr&gt;
        &lt;/xsl:for-each&gt;
      &lt;/table&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template match="rsdl:status-codes"&gt;
    &lt;em&gt;Status code&lt;xsl:if test="count(rsdl:status-code) &amp;gt; 0"&gt;s&lt;/xsl:if&gt;:&lt;/em&gt;&amp;#160;
    &lt;xsl:for-each select="rsdl:status-code"&gt;
      &lt;xsl:variable name="statusId" select="@status-code-ref"/&gt;
      &lt;a&gt;
        &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$statusId"/&gt;&lt;/xsl:attribute&gt;
        &lt;code&gt;&lt;xsl:value-of select="//rsdl:status-codes/rsdl:status[@id = $statusId]/@code"/&gt;&lt;/code&gt;
      &lt;/a&gt;
      &lt;xsl:if test="position() &amp;lt; count(../rsdl:status-code)"&gt;, &amp;#160;&lt;/xsl:if&gt;
    &lt;/xsl:for-each&gt;
    &lt;br/&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template match="rsdl:header"&gt;
    &lt;xsl:variable name="id" select="@header-ref"/&gt;
    &lt;em&gt;Header:&lt;/em&gt;&amp;#160;
    &lt;a&gt;
      &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$id"/&gt;&lt;/xsl:attribute&gt;
      &lt;code&gt;
        &lt;xsl:apply-templates select="//rsdl:custom-headers/rsdl:custom-header[@id = $id]/@name"/&gt;
      &lt;/code&gt; 
    &lt;/a&gt;
    &lt;br/&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template match="rsdl:representation"&gt;
    &lt;xsl:variable name="id" select="@media-type-ref"/&gt;
    &lt;xsl:if test="../rsdl:documentation"&gt;
      &lt;br/&gt;
    &lt;/xsl:if&gt;
    &lt;em&gt;Media type:&lt;/em&gt;&amp;#160;&lt;code&gt;
    &lt;a&gt;
      &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$id"/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select="//rsdl:media-types/rsdl:media-type[@id = $id]/@name"/&gt;
    &lt;/a&gt;
    &lt;/code&gt;
    &lt;xsl:if test="@entity"&gt;, entity: &lt;code&gt;&lt;xsl:value-of select="@entity"/&gt;&lt;/code&gt;&lt;/xsl:if&gt;
    &lt;xsl:if test="@entry"&gt;
      &lt;xsl:variable name="resId" select="@entry"/&gt;
      &lt;xsl:text&gt;, entry:&lt;/xsl:text&gt;&amp;#160; 
      &lt;code&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$resId"&gt;&lt;/xsl:value-of&gt;&lt;/xsl:attribute&gt;
          &lt;xsl:value-of select="//rsdl:resources/rsdl:resource[@id = $resId]/@name"/&gt;
        &lt;/a&gt;
      &lt;/code&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="rsdl:documentation"&gt;
      &lt;br/&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;xsl:apply-templates select="rsdl:documentation"/&gt;
    &lt;/xsl:if&gt;
    &lt;br/&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template match="rsdl:links"&gt;
    &lt;xsl:if test="rsdl:link"&gt;
      &lt;h4&gt;Links to other resources&lt;/h4&gt;
      &lt;xsl:variable name="showStatus" select="rsdl:link/@status"/&gt;
	    &lt;table&gt;
	      &lt;tr&gt;
	        &lt;xsl:if test="$showStatus"&gt; 
            &lt;th&gt;Status&lt;/th&gt;
	        &lt;/xsl:if&gt;
	        &lt;th&gt;Relation&lt;/th&gt;
	        &lt;th&gt;Resource&lt;/th&gt;
          &lt;xsl:if test="rsdl:link/rsdl:documentation"&gt;
	          &lt;th&gt;Description&lt;/th&gt;
          &lt;/xsl:if&gt;
	      &lt;/tr&gt;
	      &lt;xsl:for-each select="rsdl:link"&gt;
	        &lt;xsl:sort select="@resource-ref"/&gt;
          &lt;xsl:variable name="resId" select="@resource-ref"/&gt;
          &lt;xsl:variable name="relId" select="@link-relation-ref"/&gt;
	        &lt;tr&gt;
            &lt;xsl:if test="$showStatus"&gt;
              &lt;td class="center"&gt;
                &lt;xsl:call-template name="implemented"/&gt;
              &lt;/td&gt;
            &lt;/xsl:if&gt;
	          &lt;td&gt;
	            &lt;code&gt;
                &lt;a&gt;
                  &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$relId"&gt;&lt;/xsl:value-of&gt;&lt;/xsl:attribute&gt;
                  &lt;xsl:value-of select="//rsdl:link-relations/rsdl:link-relation[@id = $relId]/@name"/&gt;
                &lt;/a&gt;
	            &lt;/code&gt;
	          &lt;/td&gt;
	          &lt;td&gt;
	            &lt;code&gt;
	              &lt;a&gt;
	                &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$resId"&gt;&lt;/xsl:value-of&gt;&lt;/xsl:attribute&gt;
	                &lt;xsl:value-of select="//rsdl:resources/rsdl:resource[@id = $resId]/@name"/&gt;
	              &lt;/a&gt;
              &lt;/code&gt;
	          &lt;/td&gt;
            &lt;xsl:if test="../rsdl:link/rsdl:documentation"&gt;
  	          &lt;td&gt;
  	            &lt;xsl:apply-templates select="rsdl:documentation/*|rsdl:documentation/text()"/&gt;
  	          &lt;/td&gt;
            &lt;/xsl:if&gt;
	        &lt;/tr&gt;
	      &lt;/xsl:for-each&gt;
	    &lt;/table&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template match="rsdl:location"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="../@id = /rsdl:service/@home-resource"&gt;
        &lt;h4&gt;Location&lt;/h4&gt;
        &lt;p&gt;
          Reach this resource at &lt;code&gt;&lt;xsl:value-of select="@href"/&gt;&lt;/code&gt;.
        &lt;/p&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@template and rsdl:var[@uri-parameter-ref]"&gt;
        &lt;h4&gt;URI Parameters&lt;/h4&gt;
        &lt;table&gt;
          &lt;tr&gt;
            &lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Description&lt;/th&gt;
          &lt;/tr&gt;
          &lt;xsl:for-each select="rsdl:var"&gt;
            &lt;xsl:sort select="@name"/&gt;
            &lt;xsl:variable name="id" select="@uri-parameter-ref"/&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;&lt;/td&gt;
              &lt;td&gt;&lt;xsl:apply-templates select="//rsdl:uri-parameters/rsdl:uri-parameter[@id = $id]/rsdl:documentation"/&gt;&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/table&gt;
      &lt;/xsl:when&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="authentication-mechanisms"&gt;
    &lt;xsl:if test="//rsdl:authentication/rsdl:mechanism"&gt;
      &lt;hr/&gt;
      &lt;h2&gt;Authentication Mechanisms&lt;/h2&gt;
      &lt;xsl:for-each select="//rsdl:authentication/rsdl:mechanism"&gt;
        &lt;xsl:sort select="@name"/&gt;
        &lt;h3&gt;
          &lt;a&gt;
            &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
          &lt;/a&gt;
          &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
        &lt;/h3&gt;
        &lt;xsl:apply-templates select="rsdl:documentation"/&gt;
        &lt;xsl:for-each select="rsdl:scheme"&gt;
          &lt;xsl:sort select="@name"/&gt;
          &lt;xsl:apply-templates select="." /&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="rsdl:scheme"&gt;
    &lt;h4&gt;Scheme: &lt;em&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/em&gt;&lt;/h4&gt;
    &lt;xsl:if test="rsdl:documentation"&gt;
      &lt;p&gt;&lt;xsl:apply-templates select="rsdl:documentation"/&gt;&lt;/p&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="rsdl:parameter"&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;th&gt;Parameter&lt;/th&gt;
          &lt;th&gt;Description&lt;/th&gt;
        &lt;/tr&gt;
        &lt;xsl:for-each select="rsdl:parameter"&gt;
          &lt;xsl:sort select="@name"/&gt;
          &lt;tr&gt;
            &lt;td&gt;&lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;&lt;xsl:apply-templates select="rsdl:documentation"/&gt;&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/xsl:for-each&gt;
      &lt;/table&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
         
  &lt;xsl:template name="status-codes"&gt;
    &lt;xsl:if test="//rsdl:status-codes/rsdl:status"&gt;
      &lt;hr/&gt;
      &lt;h2&gt;Status Codes&lt;/h2&gt;
      &lt;xsl:for-each select="//rsdl:status-codes/rsdl:status"&gt;
        &lt;xsl:sort select="@code"/&gt;
        &lt;h3&gt;
          &lt;a&gt;
            &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
          &lt;/a&gt;
          &lt;code&gt;&lt;xsl:value-of select="@code"/&gt;&lt;/code&gt;
        &lt;/h3&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="custom-headers"&gt;
    &lt;xsl:if test="//rsdl:custom-headers/rsdl:custom-header"&gt;
      &lt;hr/&gt;
      &lt;h2&gt;Headers&lt;/h2&gt;
      &lt;xsl:for-each select="//rsdl:custom-headers/rsdl:custom-header"&gt;
        &lt;xsl:sort select="@name"/&gt;
        &lt;h3&gt;
          &lt;a&gt;
            &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
          &lt;/a&gt;
          &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;&amp;#160;&amp;#160;&lt;span class="header-suffix"&gt;(&lt;xsl:value-of select="@type"/&gt;)&lt;/span&gt;
        &lt;/h3&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="media-types"&gt;
    &lt;hr/&gt;
    &lt;h2&gt;Media-types&lt;/h2&gt;
    &lt;xsl:for-each select="//rsdl:media-types/rsdl:media-type"&gt;
      &lt;xsl:sort select="@name"/&gt;
      &lt;h3&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
        &lt;/a&gt;
        &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
      &lt;/h3&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template match="rsdl:description"&gt;
    &lt;br/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@type = 'html'"&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="href"&gt;
            &lt;xsl:value-of select="@href"/&gt;
          &lt;/xsl:attribute&gt;
          More information
        &lt;/a&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@type = 'sedola'"&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="href"&gt;
            &lt;xsl:value-of select="@href"/&gt;
          &lt;/xsl:attribute&gt;
          Service registration
        &lt;/a&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@type = 'xsd'"&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="href"&gt;
            &lt;xsl:value-of select="@href"/&gt;
          &lt;/xsl:attribute&gt;
          XML Schema
        &lt;/a&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@type = 'rnc'"&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="href"&gt;
            &lt;xsl:value-of select="@href"/&gt;
          &lt;/xsl:attribute&gt;
          Relax NG Schema
        &lt;/a&gt;
      &lt;/xsl:when&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="link-relations"&gt;
    &lt;hr/&gt;
    &lt;h2&gt;Link Relations&lt;/h2&gt;
    &lt;xsl:for-each select="//rsdl:link-relations/rsdl:link-relation"&gt;
      &lt;xsl:sort select="@name"/&gt;
      &lt;h3&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
        &lt;/a&gt;
        &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
      &lt;/h3&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="uri-parameters"&gt;
    &lt;xsl:if test="//rsdl:uri-parameters/rsdl:uri-parameter"&gt;
      &lt;hr/&gt;
      &lt;h2&gt;URI Parameters&lt;/h2&gt;
      &lt;xsl:for-each select="//rsdl:uri-parameters/rsdl:uri-parameter"&gt;
        &lt;xsl:sort select="@name"/&gt;
        &lt;h3&gt;
          &lt;a&gt;
            &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
          &lt;/a&gt;
          &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
        &lt;/h3&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="rsdl:properties"&gt;
    &lt;xsl:if test="rsdl:property"&gt;
      &lt;h4&gt;Properties&lt;/h4&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;th&gt;Name&lt;/th&gt;
          &lt;th&gt;Description&lt;/th&gt;
        &lt;/tr&gt;
        &lt;xsl:for-each select="rsdl:property"&gt;
          &lt;xsl:sort select="@name"/&gt;
          &lt;tr&gt;
            &lt;td&gt;&lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;&lt;xsl:apply-templates select="rsdl:documentation"/&gt;&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/xsl:for-each&gt;
      &lt;/table&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
    
&lt;/xsl:stylesheet&gt;      
    </pre></div><div class="appendix"><h2 class="title" style="clear: both"><a name="appx-planets.rsdl"></a>E.&nbsp;RSDL Description for the Planets Service</h2><p>The following example is taken from <a class="xref" href="#RWS">RESTful Web Services</a>, chapter 5.</p><pre class="programlisting">
&lt;?xml version="1.0" ?&gt;
&lt;service name="Maps" 
  xmlns:html="http://www.w3.org/1999/xhtml/" xmlns="http://identifiers.emc.com/rsdl"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://identifiers.emc.com/rsdl rsdl.xsd"
  &gt;
  
  &lt;documentation&gt;
    This is an example from the book RESTful Web Services, chapter 5.
  &lt;/documentation&gt;
  
  &lt;start ref="res-planets"/&gt;  

  &lt;media-types&gt;
    &lt;media-type id="med-xhtml" name="application/xhtml+xml"&gt;
      &lt;documentation&gt;
        We are defining an XHTML &lt;html:em&gt;microformat&lt;/html:em&gt; by adding meaning using the &lt;html:code&gt;class&lt;/html:code&gt;
        attribute to elements. For example, adding &lt;html:code&gt;class="planets"&lt;/html:code&gt; to the 
        &lt;html:code&gt;ul&lt;/html:code&gt; element, we can turn a list into a list of planets. 
      &lt;/documentation&gt;
      &lt;description type="html" href="http://tools.ietf.org/html/rfc3236" /&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-png" name="image/png"&gt;
      &lt;description type="html" href="http://www.iana.org/assignments/media-types/image/png" /&gt;
    &lt;/media-type&gt;
  &lt;/media-types&gt;
  
  &lt;resources&gt;
    &lt;resource id="res-planets" name="planets"&gt;
      &lt;location  uri="/"/&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-place" resource-ref="res-place"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-xhtml" entity="html"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;
    
    &lt;resource id="res-place" name="place"&gt;
      &lt;location template="/{planet}/[{scoping-information}/][{place-name}]{?show}"&gt;
        &lt;var name="planet" uri-parameter-ref="par-planet"/&gt;
        &lt;var name="scoping-information" uri-parameter-ref="par-scoping-information"/&gt;
        &lt;var name="place-name" uri-parameter-ref="par-place-name"/&gt;
        &lt;var name="show" uri-parameter-ref="par-show"/&gt;
      &lt;/location&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-map" resource-ref="res-map"/&gt;
        &lt;link link-relation-ref="rel-point" resource-ref="res-point"/&gt;
        &lt;link link-relation-ref="rel-place" resource-ref="res-place"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-xhtml" entity="html"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;
    
    &lt;resource id="res-point" name="point"&gt;
      &lt;location template="/{planet}/{latitude},{longitude}"&gt;
        &lt;var name="planet" uri-parameter-ref="par-planet"/&gt;
        &lt;var name="latitude" uri-parameter-ref="par-latitude"/&gt;
        &lt;var name="longitude" uri-parameter-ref="par-longitude"/&gt;
      &lt;/location&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-place" resource-ref="res-place"/&gt;
        &lt;link link-relation-ref="rel-point" resource-ref="res-point"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-xhtml" entity="html"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;
    
    &lt;resource id="res-map" name="map"&gt;
      &lt;location template="/{map-type}{scale}/{planet}/{latitude},{longitude}"&gt;
        &lt;var name="map-type" uri-parameter-ref="par-map-type"/&gt;
        &lt;var name="scale" uri-parameter-ref="par-scale"/&gt;
        &lt;var name="planet" uri-parameter-ref="par-planet"/&gt;
        &lt;var name="latitude" uri-parameter-ref="par-latitude"/&gt;
        &lt;var name="longitude" uri-parameter-ref="par-longitude"/&gt;
      &lt;/location&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-image" resource-ref="res-image"/&gt;
        &lt;link link-relation-ref="rel-map" resource-ref="res-map"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-xhtml" entity="html"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;
    
    &lt;resource id="res-image" name="image"&gt;
      &lt;location template="/{map-type}{scale}/{planet}/images/{latitude},{longitude}.png"&gt;
        &lt;var name="map-type" uri-parameter-ref="par-map-type"/&gt;
        &lt;var name="scale" uri-parameter-ref="par-scale"/&gt;
        &lt;var name="planet" uri-parameter-ref="par-planet"/&gt;
        &lt;var name="latitude" uri-parameter-ref="par-latitude"/&gt;
        &lt;var name="longitude" uri-parameter-ref="par-longitude"/&gt;
      &lt;/location&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-png"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;

  &lt;link-relations&gt;
    &lt;link-relation id="rel-place" name="place"&gt;
      &lt;documentation&gt;
        The target resource is a related place. Links of this type are found by looking for &lt;html:code&gt;a&lt;/html:code&gt;
        elements with &lt;html:code&gt;class="place"&lt;/html:code&gt;. Additionally, you can find search links to places via
        the &lt;html:code&gt;form&lt;/html:code&gt; element with &lt;html:code&gt;id="searchPlace"&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/link-relation&gt;
    &lt;link-relation id="rel-point" name="point"&gt;
      &lt;documentation&gt;
        The target resource is a related point on a planet. Links of this type are found by looking for 
        &lt;html:code&gt;a&lt;/html:code&gt; elements with different values for the &lt;html:code&gt;class&lt;/html:code&gt; attribute,
        like &lt;html:code&gt;coordinates&lt;/html:code&gt;, &lt;html:code&gt;map_nav&lt;/html:code&gt;, &lt;html:code&gt;zoom_in&lt;/html:code&gt;, 
        and &lt;html:code&gt;zoom_out&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/link-relation&gt;
    &lt;link-relation id="rel-map" name="map"&gt;
      &lt;documentation&gt;
        The target resource is a map related to the current resource. Links of this type are found by looking for 
        &lt;html:code&gt;a&lt;/html:code&gt;
        elements with &lt;html:code&gt;class="map"&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/link-relation&gt;
    &lt;link-relation id="rel-image" name="image"&gt;
      &lt;documentation&gt;
        The target resource is an image related to the current resource. Links of this type are found by looking for 
        &lt;html:code&gt;img&lt;/html:code&gt;
        elements with &lt;html:code&gt;class="map"&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/link-relation&gt;
  &lt;/link-relations&gt;
  
  &lt;uri-parameters&gt;
    &lt;uri-parameter id="par-planet" name="planet" datatype="string"&gt;
      &lt;documentation&gt;
        Human friendly name of a planet, like &lt;html:code&gt;Earth&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-place-name" name="place-name" datatype="string"&gt;
      &lt;documentation&gt;
        Human friendly name of a place, like &lt;html:code&gt;Mount%20Rushmore&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-scoping-information" name="scoping-information" datatype="string"&gt;
      &lt;documentation&gt;
        A hierarchy of &lt;ref uri-parameter="par-place-name"&gt;place names&lt;/ref&gt; like 
        &lt;html:code&gt;/USA/New%20England/Maine/&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-map-type" name="map-type" datatype="string"&gt;
      &lt;documentation&gt;
        The type of map, like &lt;html:code&gt;satellite&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-scale" name="scale" datatype="string"&gt;
      &lt;documentation&gt;
        Dot followed by an integer, like &lt;html:code&gt;.1&lt;/html:code&gt;. A bigger number indicates more details.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-show" name="show" datatype="string"&gt;
      &lt;documentation&gt;
        Things to search for near a given place, like &lt;html:code&gt;diners&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-latitude" name="latitude" datatype="float"&gt;
      &lt;documentation&gt;
        Latitude on a planet, like &lt;html:code&gt;24.9195&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-longitude" name="longitude" datatype="float"&gt;
      &lt;documentation&gt;
        Longitude on a planet, like &lt;html:code&gt;17.821&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
  &lt;/uri-parameters&gt;  
&lt;/service&gt;      
    </pre></div><div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a name="d5e301"></a>Bibliography</h2></div></div></div><div class="bibliomixed"><a name="WADL"></a><p class="bibliomixed">[WADL] Marc Hadley, Sun Microsystems. <span class="ital">Web Application Description Language</span>, W3C Member Submission 31 August 2009.
        http://www.w3.org/Submission/wadl/.</p></div><div class="bibliomixed"><a name="rfc6570"></a><p class="bibliomixed">[URI Templates] Joe Gregorio, Google; Roy Fielding,
      Adobe; Marc Hadley, MITRE; Mark Nottingham, Rackspace; David Orchard, Salesforce.com.
        <span class="ital">URI Template</span>, IETF RFC 6570, March 2012.
        http://tools.ietf.org/html/rfc6570</p></div><div class="bibliomixed"><a name="json-home"></a><p class="bibliomixed">[JSON Home Documents] Mark Nottingham, Rackspace.
        <span class="ital">Home Documents for HTTP APIs</span>, May 8, 2013.
        http://www.ietf.org/id/draft-nottingham-json-home-03.txt</p></div><div class="bibliomixed"><a name="xml-home"></a><p class="bibliomixed">[XML Home Documents] Erik Wilde, EMC. <span class="ital">Home Documents for HTTP Services: XML Syntax</span>, June 11, 2013.
        http://www.ietf.org/id/draft-wilde-home-xml-01.txt</p></div><div class="bibliomixed"><a name="rfc6838"></a><p class="bibliomixed">[Media Type       Specifications and Registration Procedures] N. Freed, Oracle; J.
      Klensin; T. Hansen, AT&amp;T Laboratories. <span class="ital">Media Type Specifications and
        Registration Procedures</span>, IETF RFC 6838, January 2013.
        http://tools.ietf.org/html/rfc6838</p></div><div class="bibliomixed"><a name="Burke"></a><p class="bibliomixed">[To WADL or not to WADL]  Bill Burke. <span class="ital">To WADL or not to WADL</span>, blog post, May 21, 2009.
        http://bill.burkecentral.com/2009/05/21/to-wadl-or-not-to-wadl/.</p></div><div class="bibliomixed"><a name="hypertext-driven"></a><p class="bibliomixed">[REST APIs must be hypertext-driven]  Roy
      Fielding. <span class="ital">REST APIs must be hypertext-driven</span>, blog post, Mon
      20 Oct 2008.
        http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven/.</p></div><div class="bibliomixed"><a name="draft-nottingham-json-home-02"></a><p class="bibliomixed">[Home Documents for HTTP APIs] 
      <span class="ital">Home Documents for HTTP APIs</span>,
      http://tools.ietf.org/html/draft-nottingham-json-home-02.
        http://tools.ietf.org/html/draft-nottingham-json-home-02</p></div><div class="bibliomixed"><a name="draft-nottingham-http-problem-04"></a><p class="bibliomixed">[Problem Details for HTTP APIs] 
      <span class="ital">Problem Details for HTTP APIs</span>,
      http://datatracker.ietf.org/doc/draft-nottingham-http-problem/.
        http://datatracker.ietf.org/doc/draft-nottingham-http-problem/</p></div><div class="bibliomixed"><a name="rfc3023"></a><p class="bibliomixed">[XML Media Types] 
      <span class="ital">XML Media Types</span>, IETF RFC 3023, MURATA Makoto (FAMILY Given),
      Simon St.Laurent, Daniel Kohn. http://tools.ietf.org/html/rfc3023</p></div><div class="bibliomixed"><a name="rfc4288"></a><p class="bibliomixed">[Media Type Specifications and Registration Procedures] 
      <span class="ital">Media Type Specifications and Registration Procedures</span>, IETF
      RFC 4288, Ned Freed, John C. Klensin.
      http://tools.ietf.org/html/rfc4288</p></div><div class="bibliomixed"><a name="rfc5839"></a><p class="bibliomixed">[Additional Media Type Structured Syntax Suffixes] 
      <span class="ital">Additional Media Type Structured Syntax Suffixes</span>, IETF RFC
      5830, Tony Hansen, Alexey Melnikov.
      http://tools.ietf.org/html/rfc4288</p></div><div class="bibliomixed"><a name="Aristotle"></a><p class="bibliomixed">[Does REST need a service description language] 
      Aristotle Pagaltzis. <span class="ital">Does REST need a service description
        language?</span>, blog post, May 27, 2007.
      http://plasmasturm.org/log/460/.</p></div><div class="bibliomixed"><a name="Corey"></a><p class="bibliomixed">[How RESTful is Your API?]  Cory House. <span class="ital">How RESTful is your API?</span>, blog post, August 26, 2012.
        http://www.bitnative.com/2012/08/26/how-restful-is-your-api/.</p></div><div class="bibliomixed"><a name="Fowler"></a><p class="bibliomixed">[Richardson Maturity Model]  Martin Fowler. <span class="ital">Richardson Maturity Model: steps toward the glory of REST</span>, blog post,
      18 March 2010.
      http://martinfowler.com/articles/richardsonMaturityModel.html.</p></div><div class="bibliomixed"><a name="Dare"></a><p class="bibliomixed">[What's Wrong with WADL?]  Dare Obasanjo. <span class="ital">What's Wrong with WADL?</span>, blog post, June 4, 2007.
        http://www.25hoursaday.com/weblog/2007/06/04/WhatsWrongWithWADL.aspx</p></div><div class="bibliomixed"><a name="RiP"></a><p class="bibliomixed">[REST in Practice]  Jim Webber, Savas Parastatidis and Ian
      Robinson. <span class="ital">REST in Practice: Hypermedia and Systems
        Architecture</span>. O'Reilly Media; 1 edition (September 24, 2010). ISBN-13:
      978-0596805821. </p></div><div class="bibliomixed"><a name="RWS"></a><p class="bibliomixed">[RESTful Web Services]  Leonard Richardson, Sam Ruby
        <span class="ital">RESTful Web Services</span>. O'Reilly Media; Dec 17, 2008f.
      ISBN-13: 978-0596554606.</p></div><div class="bibliomixed"><a name="sedola"></a><p class="bibliomixed">[Sedola] Erik Wilde. <span class="ital">Service
        Documentation Language</span>
      https://github.com/dret/sedola/
    </p></div><div class="bibliomixed"><a name="Fielding2000"></a><p class="bibliomixed">[Architectural Styles and the Design of Network-based Software Architectures, PhD Dissertation Thesis.]  Roy Thomas Fielding, <span class="ital">Architectural Styles and the Design of
        Network-based Software Architectures, PhD Dissertation Thesis</span>, University of
      California, Irvine &copy; 2000.
        http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm.</p></div></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.d5e79" class="footnote"><p><a href="#d5e79" class="para"><sup class="para">[1] </sup></a>It cannot, of course, force a design to be RESTful, and we are confident that RSDL
          will also be used to create poor designs, but RSDL enforces some important constraints,
          makes it easier to get some important aspects of RESTful design right, and makes it easier
          to create RESTful designs collaboratively and verify them using software. A good notation
          can facilitate good design, but it does not magically produce good design. </p></div><div id="ftn.d5e110" class="footnote"><p><a href="#d5e110" class="para"><sup class="para">[2] </sup></a>Some REST designers object to naming services or resources because the names are not
            part of the interface. We believe that names are important because human beings need a
            convenient way to refer to things that they are discussing, and they can be helpful
            metadata in some systems that use RSDL descriptions.</p></div><div id="ftn.d5e139" class="footnote"><p><a href="#d5e139" class="para"><sup class="para">[3] </sup></a>We use <a class="xref" href="#sedola">Sedola</a> to describe standard media types such as Atom and
            HTML in the same structured way. If we were writing these media types ourselves, we
            would use RSDL to specify the service, and generate Sedola from the RSDL
            description.</p></div></div></div></body></html>